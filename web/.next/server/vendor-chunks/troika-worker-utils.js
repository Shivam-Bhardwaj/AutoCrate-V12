"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-worker-utils";
exports.ids = ["vendor-chunks/troika-worker-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineWorkerModule: () => (/* binding */ defineWorkerModule),\n/* harmony export */   stringifyFunction: () => (/* binding */ stringifyFunction),\n/* harmony export */   terminateWorker: () => (/* binding */ terminateWorker)\n/* harmony export */ });\n/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */ function workerBootstrap() {\n    var modules = Object.create(null);\n    // Handle messages for registering a module\n    function registerModule(ref, callback) {\n        var id = ref.id;\n        var name = ref.name;\n        var dependencies = ref.dependencies;\n        if (dependencies === void 0) dependencies = [];\n        var init = ref.init;\n        if (init === void 0) init = function() {};\n        var getTransferables = ref.getTransferables;\n        if (getTransferables === void 0) getTransferables = null;\n        // Only register once\n        if (modules[id]) {\n            return;\n        }\n        try {\n            // If any dependencies are modules, ensure they're registered and grab their value\n            dependencies = dependencies.map(function(dep) {\n                if (dep && dep.isWorkerModule) {\n                    registerModule(dep, function(depResult) {\n                        if (depResult instanceof Error) {\n                            throw depResult;\n                        }\n                    });\n                    dep = modules[dep.id].value;\n                }\n                return dep;\n            });\n            // Rehydrate functions\n            init = rehydrate(\"<\" + name + \">.init\", init);\n            if (getTransferables) {\n                getTransferables = rehydrate(\"<\" + name + \">.getTransferables\", getTransferables);\n            }\n            // Initialize the module and store its value\n            var value = null;\n            if (typeof init === \"function\") {\n                value = init.apply(void 0, dependencies);\n            } else {\n                console.error(\"worker module init function failed to rehydrate\");\n            }\n            modules[id] = {\n                id: id,\n                value: value,\n                getTransferables: getTransferables\n            };\n            callback(value);\n        } catch (err) {\n            if (!(err && err.noLog)) {\n                console.error(err);\n            }\n            callback(err);\n        }\n    }\n    // Handle messages for calling a registered module's result function\n    function callModule(ref, callback) {\n        var ref$1;\n        var id = ref.id;\n        var args = ref.args;\n        if (!modules[id] || typeof modules[id].value !== \"function\") {\n            callback(new Error(\"Worker module \" + id + \": not found or its 'init' did not return a function\"));\n        }\n        try {\n            var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n            if (result && typeof result.then === \"function\") {\n                result.then(handleResult, function(rej) {\n                    return callback(rej instanceof Error ? rej : new Error(\"\" + rej));\n                });\n            } else {\n                handleResult(result);\n            }\n        } catch (err) {\n            callback(err);\n        }\n        function handleResult(result) {\n            try {\n                var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n                if (!tx || !Array.isArray(tx) || !tx.length) {\n                    tx = undefined; //postMessage is very picky about not passing null or empty transferables\n                }\n                callback(result, tx);\n            } catch (err) {\n                console.error(err);\n                callback(err);\n            }\n        }\n    }\n    function rehydrate(name, str) {\n        var result = void 0;\n        self.troikaDefine = function(r) {\n            return result = r;\n        };\n        var url = URL.createObjectURL(new Blob([\n            \"/** \" + name.replace(/\\*/g, \"\") + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\"\n        ], {\n            type: \"application/javascript\"\n        }));\n        try {\n            importScripts(url);\n        } catch (err) {\n            console.error(err);\n        }\n        URL.revokeObjectURL(url);\n        delete self.troikaDefine;\n        return result;\n    }\n    // Handler for all messages within the worker\n    self.addEventListener(\"message\", function(e) {\n        var ref = e.data;\n        var messageId = ref.messageId;\n        var action = ref.action;\n        var data = ref.data;\n        try {\n            // Module registration\n            if (action === \"registerModule\") {\n                registerModule(data, function(result) {\n                    if (result instanceof Error) {\n                        postMessage({\n                            messageId: messageId,\n                            success: false,\n                            error: result.message\n                        });\n                    } else {\n                        postMessage({\n                            messageId: messageId,\n                            success: true,\n                            result: {\n                                isCallable: typeof result === \"function\"\n                            }\n                        });\n                    }\n                });\n            }\n            // Invocation\n            if (action === \"callModule\") {\n                callModule(data, function(result, transferables) {\n                    if (result instanceof Error) {\n                        postMessage({\n                            messageId: messageId,\n                            success: false,\n                            error: result.message\n                        });\n                    } else {\n                        postMessage({\n                            messageId: messageId,\n                            success: true,\n                            result: result\n                        }, transferables || undefined);\n                    }\n                });\n            }\n        } catch (err) {\n            postMessage({\n                messageId: messageId,\n                success: false,\n                error: err.stack\n            });\n        }\n    });\n}\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */ function defineMainThreadModule(options) {\n    var moduleFunc = function() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        return moduleFunc._getInitResult().then(function(initResult) {\n            if (typeof initResult === \"function\") {\n                return initResult.apply(void 0, args);\n            } else {\n                throw new Error(\"Worker module function was called but `init` did not return a callable function\");\n            }\n        });\n    };\n    moduleFunc._getInitResult = function() {\n        // We can ignore getTransferables in main thread. TODO workerId?\n        var dependencies = options.dependencies;\n        var init = options.init;\n        // Resolve dependencies\n        dependencies = Array.isArray(dependencies) ? dependencies.map(function(dep) {\n            if (dep) {\n                // If it's a worker module, use its main thread impl\n                dep = dep.onMainThread || dep;\n                // If it's a main thread worker module, use its init return value\n                if (dep._getInitResult) {\n                    dep = dep._getInitResult();\n                }\n            }\n            return dep;\n        }) : [];\n        // Invoke init with the resolved dependencies\n        var initPromise = Promise.all(dependencies).then(function(deps) {\n            return init.apply(null, deps);\n        });\n        // Cache the resolved promise for subsequent calls\n        moduleFunc._getInitResult = function() {\n            return initPromise;\n        };\n        return initPromise;\n    };\n    return moduleFunc;\n}\nvar supportsWorkers = function() {\n    var supported = false;\n    // Only attempt worker initialization in browsers; elsewhere it would just be\n    // noise e.g. loading into a Node environment for SSR.\n    if (false) { var worker; }\n    // Cached result\n    supportsWorkers = function() {\n        return supported;\n    };\n    return supported;\n};\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */ function defineWorkerModule(options) {\n    if ((!options || typeof options.init !== \"function\") && !_allowInitAsString) {\n        throw new Error(\"requires `options.init` function\");\n    }\n    var dependencies = options.dependencies;\n    var init = options.init;\n    var getTransferables = options.getTransferables;\n    var workerId = options.workerId;\n    var onMainThread = defineMainThreadModule(options);\n    if (workerId == null) {\n        workerId = \"#default\";\n    }\n    var id = \"workerModule\" + ++_workerModuleId;\n    var name = options.name || id;\n    var registrationPromise = null;\n    dependencies = dependencies && dependencies.map(function(dep) {\n        // Wrap raw functions as worker modules with no dependencies\n        if (typeof dep === \"function\" && !dep.workerModuleData) {\n            _allowInitAsString = true;\n            dep = defineWorkerModule({\n                workerId: workerId,\n                name: \"<\" + name + \"> function dependency: \" + dep.name,\n                init: \"function(){return (\\n\" + stringifyFunction(dep) + \"\\n)}\"\n            });\n            _allowInitAsString = false;\n        }\n        // Grab postable data for worker modules\n        if (dep && dep.workerModuleData) {\n            dep = dep.workerModuleData;\n        }\n        return dep;\n    });\n    function moduleFunc() {\n        var args = [], len = arguments.length;\n        while(len--)args[len] = arguments[len];\n        if (!supportsWorkers()) {\n            return onMainThread.apply(void 0, args);\n        }\n        // Register this module if needed\n        if (!registrationPromise) {\n            registrationPromise = callWorker(workerId, \"registerModule\", moduleFunc.workerModuleData);\n            var unregister = function() {\n                registrationPromise = null;\n                registeredModules[workerId].delete(unregister);\n            };\n            (registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n        }\n        // Invoke the module, returning a promise\n        return registrationPromise.then(function(ref) {\n            var isCallable = ref.isCallable;\n            if (isCallable) {\n                return callWorker(workerId, \"callModule\", {\n                    id: id,\n                    args: args\n                });\n            } else {\n                throw new Error(\"Worker module function was called but `init` did not return a callable function\");\n            }\n        });\n    }\n    moduleFunc.workerModuleData = {\n        isWorkerModule: true,\n        id: id,\n        name: name,\n        dependencies: dependencies,\n        init: stringifyFunction(init),\n        getTransferables: getTransferables && stringifyFunction(getTransferables)\n    };\n    moduleFunc.onMainThread = onMainThread;\n    return moduleFunc;\n}\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */ function terminateWorker(workerId) {\n    // Unregister all modules that were registered in that worker\n    if (registeredModules[workerId]) {\n        registeredModules[workerId].forEach(function(unregister) {\n            unregister();\n        });\n    }\n    // Terminate the Worker object\n    if (workers[workerId]) {\n        workers[workerId].terminate();\n        delete workers[workerId];\n    }\n}\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */ function stringifyFunction(fn) {\n    var str = fn.toString();\n    // If it was defined in object method/property format, it needs to be modified\n    if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n        str = \"function \" + str;\n    }\n    return str;\n}\nfunction getWorker(workerId) {\n    var worker = workers[workerId];\n    if (!worker) {\n        // Bootstrap the worker's content\n        var bootstrap = stringifyFunction(workerBootstrap);\n        // Create the worker from the bootstrap function content\n        worker = workers[workerId] = new Worker(URL.createObjectURL(new Blob([\n            \"/** Worker Module Bootstrap: \" + workerId.replace(/\\*/g, \"\") + \" **/\\n\\n;(\" + bootstrap + \")()\"\n        ], {\n            type: \"application/javascript\"\n        })));\n        // Single handler for response messages from the worker\n        worker.onmessage = function(e) {\n            var response = e.data;\n            var msgId = response.messageId;\n            var callback = openRequests[msgId];\n            if (!callback) {\n                throw new Error(\"WorkerModule response with empty or unknown messageId\");\n            }\n            delete openRequests[msgId];\n            callback(response);\n        };\n    }\n    return worker;\n}\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n    return new Promise(function(resolve, reject) {\n        var messageId = ++_messageId;\n        openRequests[messageId] = function(response) {\n            if (response.success) {\n                resolve(response.result);\n            } else {\n                reject(new Error(\"Error in worker \" + action + \" call: \" + response.error));\n            }\n        };\n        getWorker(workerId).postMessage({\n            messageId: messageId,\n            action: action,\n            data: data\n        });\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELFNBQVNBO0lBQ1AsSUFBSUMsVUFBVUMsT0FBT0MsTUFBTSxDQUFDO0lBRTVCLDJDQUEyQztJQUMzQyxTQUFTQyxlQUFlQyxHQUFHLEVBQUVDLFFBQVE7UUFDbkMsSUFBSUMsS0FBS0YsSUFBSUUsRUFBRTtRQUNmLElBQUlDLE9BQU9ILElBQUlHLElBQUk7UUFDbkIsSUFBSUMsZUFBZUosSUFBSUksWUFBWTtRQUFFLElBQUtBLGlCQUFpQixLQUFLLEdBQUlBLGVBQWUsRUFBRTtRQUNyRixJQUFJQyxPQUFPTCxJQUFJSyxJQUFJO1FBQUUsSUFBS0EsU0FBUyxLQUFLLEdBQUlBLE9BQU8sWUFBVztRQUM5RCxJQUFJQyxtQkFBbUJOLElBQUlNLGdCQUFnQjtRQUFFLElBQUtBLHFCQUFxQixLQUFLLEdBQUlBLG1CQUFtQjtRQUVuRyxxQkFBcUI7UUFDckIsSUFBSVYsT0FBTyxDQUFDTSxHQUFHLEVBQUU7WUFBRTtRQUFPO1FBRTFCLElBQUk7WUFDRixrRkFBa0Y7WUFDbEZFLGVBQWVBLGFBQWFHLEdBQUcsQ0FBQyxTQUFVQyxHQUFHO2dCQUMzQyxJQUFJQSxPQUFPQSxJQUFJQyxjQUFjLEVBQUU7b0JBQzdCVixlQUFlUyxLQUFLLFNBQVVFLFNBQVM7d0JBQ3JDLElBQUlBLHFCQUFxQkMsT0FBTzs0QkFBRSxNQUFNRDt3QkFBVTtvQkFDcEQ7b0JBQ0FGLE1BQU1aLE9BQU8sQ0FBQ1ksSUFBSU4sRUFBRSxDQUFDLENBQUNVLEtBQUs7Z0JBQzdCO2dCQUNBLE9BQU9KO1lBQ1Q7WUFFQSxzQkFBc0I7WUFDdEJILE9BQU9RLFVBQVcsTUFBTVYsT0FBTyxVQUFXRTtZQUMxQyxJQUFJQyxrQkFBa0I7Z0JBQ3BCQSxtQkFBbUJPLFVBQVcsTUFBTVYsT0FBTyxzQkFBdUJHO1lBQ3BFO1lB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QUFTa0c7UUFDWDtJQUNGO0lBQ0EsT0FBTzdCO0FBQ1Q7QUFFQSxvRUFBb0U7QUFDcEUsU0FBU2dCLFdBQVdKLFFBQVEsRUFBRW5DLE1BQU0sRUFBRUYsSUFBSTtJQUN4QyxPQUFPLElBQUlrQixRQUFRLFNBQVVzQyxPQUFPLEVBQUVDLE1BQU07UUFDMUMsSUFBSXhELFlBQVksRUFBRThCO1FBQ2xCSSxZQUFZLENBQUNsQyxVQUFVLEdBQUcsU0FBVXFELFFBQVE7WUFDMUMsSUFBSUEsU0FBU2xELE9BQU8sRUFBRTtnQkFDcEJvRCxRQUFRRixTQUFTN0UsTUFBTTtZQUN6QixPQUFPO2dCQUNMZ0YsT0FBTyxJQUFJM0YsTUFBTyxxQkFBcUJvQyxTQUFTLFlBQWFvRCxTQUFTbkYsS0FBSztZQUM3RTtRQUNGO1FBQ0FnRixVQUFVZCxVQUFVbEMsV0FBVyxDQUFDO1lBQzlCRixXQUFXQTtZQUNYQyxRQUFRQTtZQUNSRixNQUFNQTtRQUNSO0lBQ0Y7QUFDRjtBQUVrRSIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9jcmF0ZS13ZWIvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMuZXNtLmpzP2ZmMWMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWluIGNvbnRlbnQgZm9yIHRoZSB3b3JrZXIgdGhhdCBoYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBleGVjdXRpb24gb2ZcbiAqIG1vZHVsZXMgd2l0aGluIGl0LlxuICovXG5mdW5jdGlvbiB3b3JrZXJCb290c3RyYXAoKSB7XG4gIHZhciBtb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBIYW5kbGUgbWVzc2FnZXMgZm9yIHJlZ2lzdGVyaW5nIGEgbW9kdWxlXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gcmVmLmRlcGVuZGVuY2llczsgaWYgKCBkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCApIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHZhciBpbml0ID0gcmVmLmluaXQ7IGlmICggaW5pdCA9PT0gdm9pZCAwICkgaW5pdCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB2YXIgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlZi5nZXRUcmFuc2ZlcmFibGVzOyBpZiAoIGdldFRyYW5zZmVyYWJsZXMgPT09IHZvaWQgMCApIGdldFRyYW5zZmVyYWJsZXMgPSBudWxsO1xuXG4gICAgLy8gT25seSByZWdpc3RlciBvbmNlXG4gICAgaWYgKG1vZHVsZXNbaWRdKSB7IHJldHVybiB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gSWYgYW55IGRlcGVuZGVuY2llcyBhcmUgbW9kdWxlcywgZW5zdXJlIHRoZXkncmUgcmVnaXN0ZXJlZCBhbmQgZ3JhYiB0aGVpciB2YWx1ZVxuICAgICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgIGlmIChkZXAgJiYgZGVwLmlzV29ya2VyTW9kdWxlKSB7XG4gICAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGVwLCBmdW5jdGlvbiAoZGVwUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVwUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHsgdGhyb3cgZGVwUmVzdWx0IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZXAgPSBtb2R1bGVzW2RlcC5pZF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlaHlkcmF0ZSBmdW5jdGlvbnNcbiAgICAgIGluaXQgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5pbml0XCIpLCBpbml0KTtcbiAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5nZXRUcmFuc2ZlcmFibGVzXCIpLCBnZXRUcmFuc2ZlcmFibGVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBzdG9yZSBpdHMgdmFsdWVcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dvcmtlciBtb2R1bGUgaW5pdCBmdW5jdGlvbiBmYWlsZWQgdG8gcmVoeWRyYXRlJyk7XG4gICAgICB9XG4gICAgICBtb2R1bGVzW2lkXSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXNcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGlmICghKGVyciAmJiBlcnIubm9Mb2cpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciBjYWxsaW5nIGEgcmVnaXN0ZXJlZCBtb2R1bGUncyByZXN1bHQgZnVuY3Rpb25cbiAgZnVuY3Rpb24gY2FsbE1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZiQxO1xuXG4gICAgdmFyIGlkID0gcmVmLmlkO1xuICAgIHZhciBhcmdzID0gcmVmLmFyZ3M7XG4gICAgaWYgKCFtb2R1bGVzW2lkXSB8fCB0eXBlb2YgbW9kdWxlc1tpZF0udmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcigoXCJXb3JrZXIgbW9kdWxlIFwiICsgaWQgKyBcIjogbm90IGZvdW5kIG9yIGl0cyAnaW5pdCcgZGlkIG5vdCByZXR1cm4gYSBmdW5jdGlvblwiKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZWYkMSA9IG1vZHVsZXNbaWRdKS52YWx1ZS5hcHBseShyZWYkMSwgYXJncyk7XG4gICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIGZ1bmN0aW9uIChyZWopIHsgcmV0dXJuIGNhbGxiYWNrKHJlaiBpbnN0YW5jZW9mIEVycm9yID8gcmVqIDogbmV3IEVycm9yKCcnICsgcmVqKSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IG1vZHVsZXNbaWRdLmdldFRyYW5zZmVyYWJsZXMgJiYgbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpO1xuICAgICAgICBpZiAoIXR4IHx8ICFBcnJheS5pc0FycmF5KHR4KSB8fCAhdHgubGVuZ3RoKSB7XG4gICAgICAgICAgdHggPSB1bmRlZmluZWQ7IC8vcG9zdE1lc3NhZ2UgaXMgdmVyeSBwaWNreSBhYm91dCBub3QgcGFzc2luZyBudWxsIG9yIGVtcHR5IHRyYW5zZmVyYWJsZXNcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhyZXN1bHQsIHR4KTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWh5ZHJhdGUobmFtZSwgc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICBzZWxmLnRyb2lrYURlZmluZSA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXN1bHQgPSByOyB9O1xuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoXG4gICAgICAgIFsoXCIvKiogXCIgKyAobmFtZS5yZXBsYWNlKC9cXCovZywgJycpKSArIFwiICoqL1xcblxcbnRyb2lrYURlZmluZShcXG5cIiArIHN0ciArIFwiXFxuKVwiKV0sXG4gICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICApXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaW1wb3J0U2NyaXB0cyh1cmwpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBkZWxldGUgc2VsZi50cm9pa2FEZWZpbmU7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYWxsIG1lc3NhZ2VzIHdpdGhpbiB0aGUgd29ya2VyXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJlZiA9IGUuZGF0YTtcbiAgICB2YXIgbWVzc2FnZUlkID0gcmVmLm1lc3NhZ2VJZDtcbiAgICB2YXIgYWN0aW9uID0gcmVmLmFjdGlvbjtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICAvLyBNb2R1bGUgcmVnaXN0cmF0aW9uXG4gICAgICBpZiAoYWN0aW9uID09PSAncmVnaXN0ZXJNb2R1bGUnKSB7XG4gICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHtpc0NhbGxhYmxlOiB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEludm9jYXRpb25cbiAgICAgIGlmIChhY3Rpb24gPT09ICdjYWxsTW9kdWxlJykge1xuICAgICAgICBjYWxsTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLnN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZhbGxiYWNrIGZvciBgZGVmaW5lV29ya2VyTW9kdWxlYCB0aGF0IGJlaGF2ZXMgaWRlbnRpY2FsbHkgYnV0IHJ1bnMgaW4gdGhlIG1haW5cbiAqIHRocmVhZCwgZm9yIHdoZW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgd2ViIHdvcmtlcnMgb3IgdGhleVxuICogYXJlIGRpc2FsbG93ZWQgZHVlIHRvIGUuZy4gQ1NQIHNlY3VyaXR5IHJlc3RyaWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVGdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uIChpbml0UmVzdWx0KSB7XG4gICAgICBpZiAodHlwZW9mIGluaXRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuYXBwbHkodm9pZCAwLCBhcmdzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgY2FuIGlnbm9yZSBnZXRUcmFuc2ZlcmFibGVzIGluIG1haW4gdGhyZWFkLiBUT0RPIHdvcmtlcklkP1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcbiAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcblxuICAgIC8vIFJlc29sdmUgZGVwZW5kZW5jaWVzXG4gICAgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoZGVwKSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSB3b3JrZXIgbW9kdWxlLCB1c2UgaXRzIG1haW4gdGhyZWFkIGltcGxcbiAgICAgICAgZGVwID0gZGVwLm9uTWFpblRocmVhZCB8fCBkZXA7XG4gICAgICAgIC8vIElmIGl0J3MgYSBtYWluIHRocmVhZCB3b3JrZXIgbW9kdWxlLCB1c2UgaXRzIGluaXQgcmV0dXJuIHZhbHVlXG4gICAgICAgIGlmIChkZXAuX2dldEluaXRSZXN1bHQpIHtcbiAgICAgICAgICBkZXAgPSBkZXAuX2dldEluaXRSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcFxuICAgIH0pIDogW107XG5cbiAgICAvLyBJbnZva2UgaW5pdCB3aXRoIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXNcbiAgICB2YXIgaW5pdFByb21pc2UgPSBQcm9taXNlLmFsbChkZXBlbmRlbmNpZXMpLnRoZW4oZnVuY3Rpb24gKGRlcHMpIHtcbiAgICAgIHJldHVybiBpbml0LmFwcGx5KG51bGwsIGRlcHMpXG4gICAgfSk7XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzb2x2ZWQgcHJvbWlzZSBmb3Igc3Vic2VxdWVudCBjYWxsc1xuICAgIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbml0UHJvbWlzZTsgfTtcblxuICAgIHJldHVybiBpbml0UHJvbWlzZVxuICB9O1xuICByZXR1cm4gbW9kdWxlRnVuY1xufVxuXG52YXIgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgLy8gT25seSBhdHRlbXB0IHdvcmtlciBpbml0aWFsaXphdGlvbiBpbiBicm93c2VyczsgZWxzZXdoZXJlIGl0IHdvdWxkIGp1c3QgYmVcbiAgLy8gbm9pc2UgZS5nLiBsb2FkaW5nIGludG8gYSBOb2RlIGVudmlyb25tZW50IGZvciBTU1IuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPIGFkZGl0aW9uYWwgY2hlY2tzIGZvciB0aGluZ3MgbGlrZSBpbXBvcnRTY3JpcHRzIHdpdGhpbiB0aGUgd29ya2VyP1xuICAgICAgLy8gIFdvdWxkIG5lZWQgdG8gYmUgYW4gYXN5bmMgY2hlY2suXG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihcbiAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJyddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KSlcbiAgICAgICk7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSA7IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAoXCJUcm9pa2EgY3JlYXRlV29ya2VyTW9kdWxlOiB3ZWIgd29ya2VycyBub3QgYWxsb3dlZDsgZmFsbGluZyBiYWNrIHRvIG1haW4gdGhyZWFkIGV4ZWN1dGlvbi4gQ2F1c2U6IFtcIiArIChlcnIubWVzc2FnZSkgKyBcIl1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZWQgcmVzdWx0XG4gIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1cHBvcnRlZDsgfTtcbiAgcmV0dXJuIHN1cHBvcnRlZFxufTtcblxudmFyIF93b3JrZXJNb2R1bGVJZCA9IDA7XG52YXIgX21lc3NhZ2VJZCA9IDA7XG52YXIgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG52YXIgd29ya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgcmVnaXN0ZXJlZE1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvL3dvcmtlcklkIC0+IFNldDx1bnJlZ2lzdGVyRm4+XG52YXIgb3BlblJlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vKipcbiAqIERlZmluZSBhIG1vZHVsZSBvZiBjb2RlIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aXRoIGEgd2ViIHdvcmtlci4gVGhpcyBwcm92aWRlcyBhIHNpbXBsZVxuICogaW50ZXJmYWNlIGZvciBtb3ZpbmcgY2h1bmtzIG9mIGxvZ2ljIG9mZiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBtYW5hZ2luZyB0aGVpciBkZXBlbmRlbmNpZXNcbiAqIGFtb25nIG9uZSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmluaXRcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmRlcGVuZGVuY2llc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdldFRyYW5zZmVyYWJsZXNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53b3JrZXJJZF1cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSk6IHt0aGVufX1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lV29ya2VyTW9kdWxlKG9wdGlvbnMpIHtcbiAgaWYgKCghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5pbml0ICE9PSAnZnVuY3Rpb24nKSAmJiAhX2FsbG93SW5pdEFzU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBgb3B0aW9ucy5pbml0YCBmdW5jdGlvbicpXG4gIH1cbiAgdmFyIGRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xuICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcbiAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSBvcHRpb25zLmdldFRyYW5zZmVyYWJsZXM7XG4gIHZhciB3b3JrZXJJZCA9IG9wdGlvbnMud29ya2VySWQ7XG5cbiAgdmFyIG9uTWFpblRocmVhZCA9IGRlZmluZU1haW5UaHJlYWRNb2R1bGUob3B0aW9ucyk7XG5cbiAgaWYgKHdvcmtlcklkID09IG51bGwpIHtcbiAgICB3b3JrZXJJZCA9ICcjZGVmYXVsdCc7XG4gIH1cbiAgdmFyIGlkID0gXCJ3b3JrZXJNb2R1bGVcIiArICgrK193b3JrZXJNb2R1bGVJZCk7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IGlkO1xuICB2YXIgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgIC8vIFdyYXAgcmF3IGZ1bmN0aW9ucyBhcyB3b3JrZXIgbW9kdWxlcyB3aXRoIG5vIGRlcGVuZGVuY2llc1xuICAgIGlmICh0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nICYmICFkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gdHJ1ZTtcbiAgICAgIGRlcCA9IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIHdvcmtlcklkOiB3b3JrZXJJZCxcbiAgICAgICAgbmFtZTogKFwiPFwiICsgbmFtZSArIFwiPiBmdW5jdGlvbiBkZXBlbmRlbmN5OiBcIiArIChkZXAubmFtZSkpLFxuICAgICAgICBpbml0OiAoXCJmdW5jdGlvbigpe3JldHVybiAoXFxuXCIgKyAoc3RyaW5naWZ5RnVuY3Rpb24oZGVwKSkgKyBcIlxcbil9XCIpXG4gICAgICB9KTtcbiAgICAgIF9hbGxvd0luaXRBc1N0cmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBHcmFiIHBvc3RhYmxlIGRhdGEgZm9yIHdvcmtlciBtb2R1bGVzXG4gICAgaWYgKGRlcCAmJiBkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgZGVwID0gZGVwLndvcmtlck1vZHVsZURhdGE7XG4gICAgfVxuICAgIHJldHVybiBkZXBcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbW9kdWxlRnVuYygpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoIXN1cHBvcnRzV29ya2VycygpKSB7XG4gICAgICByZXR1cm4gb25NYWluVGhyZWFkLmFwcGx5KHZvaWQgMCwgYXJncylcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIG1vZHVsZSBpZiBuZWVkZWRcbiAgICBpZiAoIXJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UgPSBjYWxsV29ya2VyKHdvcmtlcklkLCdyZWdpc3Rlck1vZHVsZScsIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSk7XG4gICAgICB2YXIgdW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXS5kZWxldGUodW5yZWdpc3Rlcik7XG4gICAgICB9XG4gICAgICA7KHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXSB8fCAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdID0gbmV3IFNldCgpKSkuYWRkKHVucmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIC8vIEludm9rZSB0aGUgbW9kdWxlLCByZXR1cm5pbmcgYSBwcm9taXNlXG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlZi5pc0NhbGxhYmxlO1xuXG4gICAgICBpZiAoaXNDYWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gY2FsbFdvcmtlcih3b3JrZXJJZCwnY2FsbE1vZHVsZScsIHtpZDogaWQsIGFyZ3M6IGFyZ3N9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSA9IHtcbiAgICBpc1dvcmtlck1vZHVsZTogdHJ1ZSxcbiAgICBpZDogaWQsXG4gICAgbmFtZTogbmFtZSxcbiAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICBpbml0OiBzdHJpbmdpZnlGdW5jdGlvbihpbml0KSxcbiAgICBnZXRUcmFuc2ZlcmFibGVzOiBnZXRUcmFuc2ZlcmFibGVzICYmIHN0cmluZ2lmeUZ1bmN0aW9uKGdldFRyYW5zZmVyYWJsZXMpXG4gIH07XG5cbiAgbW9kdWxlRnVuYy5vbk1haW5UaHJlYWQgPSBvbk1haW5UaHJlYWQ7XG5cbiAgcmV0dXJuIG1vZHVsZUZ1bmNcbn1cblxuLyoqXG4gKiBUZXJtaW5hdGUgYW4gYWN0aXZlIFdvcmtlciBieSBhIHdvcmtlcklkIHRoYXQgd2FzIHBhc3NlZCB0byBkZWZpbmVXb3JrZXJNb2R1bGUuXG4gKiBUaGlzIG9ubHkgdGVybWluYXRlcyB0aGUgV29ya2VyIGl0c2VsZjsgdGhlIHdvcmtlciBtb2R1bGUgd2lsbCByZW1haW4gYXZhaWxhYmxlXG4gKiBhbmQgaWYgeW91IGNhbGwgaXQgYWdhaW4gaXRzIFdvcmtlciB3aWxsIGJlIHJlc3Bhd25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JrZXJJZFxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpIHtcbiAgLy8gVW5yZWdpc3RlciBhbGwgbW9kdWxlcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZCBpbiB0aGF0IHdvcmtlclxuICBpZiAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdKSB7XG4gICAgcmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdLmZvckVhY2goZnVuY3Rpb24gKHVucmVnaXN0ZXIpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBUZXJtaW5hdGUgdGhlIFdvcmtlciBvYmplY3RcbiAgaWYgKHdvcmtlcnNbd29ya2VySWRdKSB7XG4gICAgd29ya2Vyc1t3b3JrZXJJZF0udGVybWluYXRlKCk7XG4gICAgZGVsZXRlIHdvcmtlcnNbd29ya2VySWRdO1xuICB9XG59XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBmdW5jdGlvbiBpbnRvIGEgZm9ybSB0aGF0IGNhbiBiZSBkZXNlcmlhbGl6ZWQgaW4gdGhlIHdvcmtlclxuICogQHBhcmFtIGZuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKGZuKSB7XG4gIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAvLyBJZiBpdCB3YXMgZGVmaW5lZCBpbiBvYmplY3QgbWV0aG9kL3Byb3BlcnR5IGZvcm1hdCwgaXQgbmVlZHMgdG8gYmUgbW9kaWZpZWRcbiAgaWYgKCEvXmZ1bmN0aW9uLy50ZXN0KHN0cikgJiYgL15cXHcrXFxzKlxcKC8udGVzdChzdHIpKSB7XG4gICAgc3RyID0gJ2Z1bmN0aW9uICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5cbmZ1bmN0aW9uIGdldFdvcmtlcih3b3JrZXJJZCkge1xuICB2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG4gIGlmICghd29ya2VyKSB7XG4gICAgLy8gQm9vdHN0cmFwIHRoZSB3b3JrZXIncyBjb250ZW50XG4gICAgdmFyIGJvb3RzdHJhcCA9IHN0cmluZ2lmeUZ1bmN0aW9uKHdvcmtlckJvb3RzdHJhcCk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHdvcmtlciBmcm9tIHRoZSBib290c3RyYXAgZnVuY3Rpb24gY29udGVudFxuICAgIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdID0gbmV3IFdvcmtlcihcbiAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFxuICAgICAgICAgIFsoXCIvKiogV29ya2VyIE1vZHVsZSBCb290c3RyYXA6IFwiICsgKHdvcmtlcklkLnJlcGxhY2UoL1xcKi9nLCAnJykpICsgXCIgKiovXFxuXFxuOyhcIiArIGJvb3RzdHJhcCArIFwiKSgpXCIpXSxcbiAgICAgICAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIFNpbmdsZSBoYW5kbGVyIGZvciByZXNwb25zZSBtZXNzYWdlcyBmcm9tIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGUuZGF0YTtcbiAgICAgIHZhciBtc2dJZCA9IHJlc3BvbnNlLm1lc3NhZ2VJZDtcbiAgICAgIHZhciBjYWxsYmFjayA9IG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyTW9kdWxlIHJlc3BvbnNlIHdpdGggZW1wdHkgb3IgdW5rbm93biBtZXNzYWdlSWQnKVxuICAgICAgfVxuICAgICAgZGVsZXRlIG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd29ya2VyXG59XG5cbi8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG5mdW5jdGlvbiBjYWxsV29ya2VyKHdvcmtlcklkLCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbWVzc2FnZUlkID0gKytfbWVzc2FnZUlkO1xuICAgIG9wZW5SZXF1ZXN0c1ttZXNzYWdlSWRdID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKChcIkVycm9yIGluIHdvcmtlciBcIiArIGFjdGlvbiArIFwiIGNhbGw6IFwiICsgKHJlc3BvbnNlLmVycm9yKSkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldFdvcmtlcih3b3JrZXJJZCkucG9zdE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfSlcbn1cblxuZXhwb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCBzdHJpbmdpZnlGdW5jdGlvbiwgdGVybWluYXRlV29ya2VyIH07XG4iXSwibmFtZXMiOlsid29ya2VyQm9vdHN0cmFwIiwibW9kdWxlcyIsIk9iamVjdCIsImNyZWF0ZSIsInJlZ2lzdGVyTW9kdWxlIiwicmVmIiwiY2FsbGJhY2siLCJpZCIsIm5hbWUiLCJkZXBlbmRlbmNpZXMiLCJpbml0IiwiZ2V0VHJhbnNmZXJhYmxlcyIsIm1hcCIsImRlcCIsImlzV29ya2VyTW9kdWxlIiwiZGVwUmVzdWx0IiwiRXJyb3IiLCJ2YWx1ZSIsInJlaHlkcmF0ZSIsImFwcGx5IiwiY29uc29sZSIsImVycm9yIiwiZXJyIiwibm9Mb2ciLCJjYWxsTW9kdWxlIiwicmVmJDEiLCJhcmdzIiwicmVzdWx0IiwidGhlbiIsImhhbmRsZVJlc3VsdCIsInJlaiIsInR4IiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwidW5kZWZpbmVkIiwic3RyIiwic2VsZiIsInRyb2lrYURlZmluZSIsInIiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwicmVwbGFjZSIsInR5cGUiLCJpbXBvcnRTY3JpcHRzIiwicmV2b2tlT2JqZWN0VVJMIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJkYXRhIiwibWVzc2FnZUlkIiwiYWN0aW9uIiwicG9zdE1lc3NhZ2UiLCJzdWNjZXNzIiwibWVzc2FnZSIsImlzQ2FsbGFibGUiLCJ0cmFuc2ZlcmFibGVzIiwic3RhY2siLCJkZWZpbmVNYWluVGhyZWFkTW9kdWxlIiwib3B0aW9ucyIsIm1vZHVsZUZ1bmMiLCJsZW4iLCJhcmd1bWVudHMiLCJfZ2V0SW5pdFJlc3VsdCIsImluaXRSZXN1bHQiLCJvbk1haW5UaHJlYWQiLCJpbml0UHJvbWlzZSIsIlByb21pc2UiLCJhbGwiLCJkZXBzIiwic3VwcG9ydHNXb3JrZXJzIiwic3VwcG9ydGVkIiwid2luZG93IiwiZG9jdW1lbnQiLCJ3b3JrZXIiLCJXb3JrZXIiLCJ0ZXJtaW5hdGUiLCJwcm9jZXNzIiwibG9nIiwiX3dvcmtlck1vZHVsZUlkIiwiX21lc3NhZ2VJZCIsIl9hbGxvd0luaXRBc1N0cmluZyIsIndvcmtlcnMiLCJyZWdpc3RlcmVkTW9kdWxlcyIsIm9wZW5SZXF1ZXN0cyIsImRlZmluZVdvcmtlck1vZHVsZSIsIndvcmtlcklkIiwicmVnaXN0cmF0aW9uUHJvbWlzZSIsIndvcmtlck1vZHVsZURhdGEiLCJzdHJpbmdpZnlGdW5jdGlvbiIsImNhbGxXb3JrZXIiLCJ1bnJlZ2lzdGVyIiwiZGVsZXRlIiwiU2V0IiwiYWRkIiwidGVybWluYXRlV29ya2VyIiwiZm9yRWFjaCIsImZuIiwidG9TdHJpbmciLCJ0ZXN0IiwiZ2V0V29ya2VyIiwiYm9vdHN0cmFwIiwib25tZXNzYWdlIiwicmVzcG9uc2UiLCJtc2dJZCIsInJlc29sdmUiLCJyZWplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\n");

/***/ })

};
;