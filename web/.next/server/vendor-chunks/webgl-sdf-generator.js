"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webgl-sdf-generator";
exports.ids = ["vendor-chunks/webgl-sdf-generator"];
exports.modules = {

/***/ "(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SDFGenerator)\n/* harmony export */ });\nfunction SDFGenerator() {\n    var exports = function(exports) {\n        /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */ function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {\n            var t2 = 1 - t;\n            pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n            pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n        }\n        /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */ function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n            var t2 = 1 - t;\n            pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n            pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n        }\n        /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */ function forEachPathCommand(pathString, commandCallback) {\n            var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n            var match, firstX, firstY, prevX, prevY;\n            while(match = segmentRE.exec(pathString)){\n                var args = match[2].replace(/^\\s*|\\s*$/g, \"\").split(/[,\\s]+/).map(function(v) {\n                    return parseFloat(v);\n                });\n                switch(match[1]){\n                    case \"M\":\n                        prevX = firstX = args[0];\n                        prevY = firstY = args[1];\n                        break;\n                    case \"L\":\n                        if (args[0] !== prevX || args[1] !== prevY) {\n                            commandCallback(\"L\", prevX, prevY, prevX = args[0], prevY = args[1]);\n                        }\n                        break;\n                    case \"Q\":\n                        {\n                            commandCallback(\"Q\", prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);\n                            break;\n                        }\n                    case \"C\":\n                        {\n                            commandCallback(\"C\", prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);\n                            break;\n                        }\n                    case \"Z\":\n                        if (prevX !== firstX || prevY !== firstY) {\n                            commandCallback(\"L\", prevX, prevY, firstX, firstY);\n                        }\n                        break;\n                }\n            }\n        }\n        /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */ function pathToLineSegments(pathString, segmentCallback, curvePoints) {\n            if (curvePoints === void 0) curvePoints = 16;\n            var tempPoint = {\n                x: 0,\n                y: 0\n            };\n            forEachPathCommand(pathString, function(command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n                switch(command){\n                    case \"L\":\n                        segmentCallback(startX, startY, endX, endY);\n                        break;\n                    case \"Q\":\n                        {\n                            var prevCurveX = startX;\n                            var prevCurveY = startY;\n                            for(var i = 1; i < curvePoints; i++){\n                                pointOnQuadraticBezier(startX, startY, ctrl1X, ctrl1Y, endX, endY, i / (curvePoints - 1), tempPoint);\n                                segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n                                prevCurveX = tempPoint.x;\n                                prevCurveY = tempPoint.y;\n                            }\n                            break;\n                        }\n                    case \"C\":\n                        {\n                            var prevCurveX$1 = startX;\n                            var prevCurveY$1 = startY;\n                            for(var i$1 = 1; i$1 < curvePoints; i$1++){\n                                pointOnCubicBezier(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, i$1 / (curvePoints - 1), tempPoint);\n                                segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n                                prevCurveX$1 = tempPoint.x;\n                                prevCurveY$1 = tempPoint.y;\n                            }\n                            break;\n                        }\n                }\n            });\n        }\n        var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n        var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n        var cache = new WeakMap();\n        var glContextParams = {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: true,\n            antialias: false,\n            depth: false\n        };\n        /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */ function withWebGLContext(glOrCanvas, callback) {\n            var gl = glOrCanvas.getContext ? glOrCanvas.getContext(\"webgl\", glContextParams) : glOrCanvas;\n            var wrapper = cache.get(gl);\n            if (!wrapper) {\n                var isWebGL2 = typeof WebGL2RenderingContext !== \"undefined\" && gl instanceof WebGL2RenderingContext;\n                var extensions = {};\n                var programs = {};\n                var textures = {};\n                var textureUnit = -1;\n                var framebufferStack = [];\n                gl.canvas.addEventListener(\"webglcontextlost\", function(e) {\n                    handleContextLoss();\n                    e.preventDefault();\n                }, false);\n                function getExtension(name) {\n                    var ext = extensions[name];\n                    if (!ext) {\n                        ext = extensions[name] = gl.getExtension(name);\n                        if (!ext) {\n                            throw new Error(name + \" not supported\");\n                        }\n                    }\n                    return ext;\n                }\n                function compileShader(src, type) {\n                    var shader = gl.createShader(type);\n                    gl.shaderSource(shader, src);\n                    gl.compileShader(shader);\n                    // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n                    // if (!status && !gl.isContextLost()) {\n                    //   throw new Error(gl.getShaderInfoLog(shader).trim())\n                    // }\n                    return shader;\n                }\n                function withProgram(name, vert, frag, func) {\n                    if (!programs[name]) {\n                        var attributes = {};\n                        var uniforms = {};\n                        var program = gl.createProgram();\n                        gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n                        gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n                        gl.linkProgram(program);\n                        programs[name] = {\n                            program: program,\n                            transaction: function transaction(func) {\n                                gl.useProgram(program);\n                                func({\n                                    setUniform: function setUniform(type, name) {\n                                        var values = [], len = arguments.length - 2;\n                                        while(len-- > 0)values[len] = arguments[len + 2];\n                                        var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                                        gl[\"uniform\" + type].apply(gl, [\n                                            uniformLoc\n                                        ].concat(values));\n                                    },\n                                    setAttribute: function setAttribute(name, size, usage, instancingDivisor, data) {\n                                        var attr = attributes[name];\n                                        if (!attr) {\n                                            attr = attributes[name] = {\n                                                buf: gl.createBuffer(),\n                                                loc: gl.getAttribLocation(program, name),\n                                                data: null\n                                            };\n                                        }\n                                        gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                                        gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                                        gl.enableVertexAttribArray(attr.loc);\n                                        if (isWebGL2) {\n                                            gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                                        } else {\n                                            getExtension(\"ANGLE_instanced_arrays\").vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                                        }\n                                        if (data !== attr.data) {\n                                            gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                                            attr.data = data;\n                                        }\n                                    }\n                                });\n                            }\n                        };\n                    }\n                    programs[name].transaction(func);\n                }\n                function withTexture(name, func) {\n                    textureUnit++;\n                    try {\n                        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n                        var texture = textures[name];\n                        if (!texture) {\n                            texture = textures[name] = gl.createTexture();\n                            gl.bindTexture(gl.TEXTURE_2D, texture);\n                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                        }\n                        gl.bindTexture(gl.TEXTURE_2D, texture);\n                        func(texture, textureUnit);\n                    } finally{\n                        textureUnit--;\n                    }\n                }\n                function withTextureFramebuffer(texture, textureUnit, func) {\n                    var framebuffer = gl.createFramebuffer();\n                    framebufferStack.push(framebuffer);\n                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n                    gl.activeTexture(gl.TEXTURE0 + textureUnit);\n                    gl.bindTexture(gl.TEXTURE_2D, texture);\n                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n                    try {\n                        func(framebuffer);\n                    } finally{\n                        gl.deleteFramebuffer(framebuffer);\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n                    }\n                }\n                function handleContextLoss() {\n                    extensions = {};\n                    programs = {};\n                    textures = {};\n                    textureUnit = -1;\n                    framebufferStack.length = 0;\n                }\n                cache.set(gl, wrapper = {\n                    gl: gl,\n                    isWebGL2: isWebGL2,\n                    getExtension: getExtension,\n                    withProgram: withProgram,\n                    withTexture: withTexture,\n                    withTextureFramebuffer: withTextureFramebuffer,\n                    handleContextLoss: handleContextLoss\n                });\n            }\n            callback(wrapper);\n        }\n        function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n            if (channels === void 0) channels = 15;\n            if (framebuffer === void 0) framebuffer = null;\n            withWebGLContext(glOrCanvas, function(ref) {\n                var gl = ref.gl;\n                var withProgram = ref.withProgram;\n                var withTexture = ref.withTexture;\n                withTexture(\"copy\", function(tex, texUnit) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n                    withProgram(\"copy\", viewportQuadVertex, copyTexFragment, function(ref) {\n                        var setUniform = ref.setUniform;\n                        var setAttribute = ref.setAttribute;\n                        setAttribute(\"aUV\", 2, gl.STATIC_DRAW, 0, new Float32Array([\n                            0,\n                            0,\n                            2,\n                            0,\n                            0,\n                            2\n                        ]));\n                        setUniform(\"1i\", \"image\", texUnit);\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n                        gl.disable(gl.BLEND);\n                        gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n                        gl.viewport(x, y, width, height);\n                        gl.scissor(x, y, width, height);\n                        gl.drawArrays(gl.TRIANGLES, 0, 3);\n                    });\n                });\n            });\n        }\n        /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */ function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n            var width = canvas.width;\n            var height = canvas.height;\n            withWebGLContext(canvas, function(ref) {\n                var gl = ref.gl;\n                var data = new Uint8Array(width * height * 4);\n                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n                canvas.width = newWidth;\n                canvas.height = newHeight;\n                renderImageData(gl, data, 0, 0, width, height);\n            });\n        }\n        var webglUtils = /*#__PURE__*/ Object.freeze({\n            __proto__: null,\n            withWebGLContext: withWebGLContext,\n            renderImageData: renderImageData,\n            resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n        });\n        function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            var textureData = new Uint8Array(sdfWidth * sdfHeight);\n            var viewBoxWidth = viewBox[2] - viewBox[0];\n            var viewBoxHeight = viewBox[3] - viewBox[1];\n            // Decompose all paths into straight line segments and add them to an index\n            var segments = [];\n            pathToLineSegments(path, function(x1, y1, x2, y2) {\n                segments.push({\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2,\n                    minX: Math.min(x1, x2),\n                    minY: Math.min(y1, y2),\n                    maxX: Math.max(x1, x2),\n                    maxY: Math.max(y1, y2)\n                });\n            });\n            // Sort segments by maxX, this will let us short-circuit some loops below\n            segments.sort(function(a, b) {\n                return a.maxX - b.maxX;\n            });\n            // For each target SDF texel, find the distance from its center to its nearest line segment,\n            // map that distance to an alpha value, and write that alpha to the texel\n            for(var sdfX = 0; sdfX < sdfWidth; sdfX++){\n                for(var sdfY = 0; sdfY < sdfHeight; sdfY++){\n                    var signedDist = findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight);\n                    // Use an exponential scale to ensure the texels very near the glyph path have adequate\n                    // precision, while allowing the distance field to cover the entire texture, given that\n                    // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n                    var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;\n                    if (signedDist < 0) {\n                        alpha = 1 - alpha;\n                    }\n                    alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n                    textureData[sdfY * sdfWidth + sdfX] = alpha;\n                }\n            }\n            return textureData;\n            /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */ function findNearestSignedDistance(x, y) {\n                var closestDistSq = Infinity;\n                var closestDist = Infinity;\n                for(var i = segments.length; i--;){\n                    var seg = segments[i];\n                    if (seg.maxX + closestDist <= x) {\n                        break;\n                    } //sorting by maxX means no more can be closer, so we can short-circuit\n                    if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n                        var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n                        if (distSq < closestDistSq) {\n                            closestDistSq = distSq;\n                            closestDist = Math.sqrt(closestDistSq);\n                        }\n                    }\n                }\n                // Flip to negative distance if inside the poly\n                if (isPointInPoly(x, y)) {\n                    closestDist = -closestDist;\n                }\n                return closestDist;\n            }\n            /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */ function isPointInPoly(x, y) {\n                var winding = 0;\n                for(var i = segments.length; i--;){\n                    var seg = segments[i];\n                    if (seg.maxX <= x) {\n                        break;\n                    } //sorting by maxX means no more can cross, so we can short-circuit\n                    var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;\n                    if (intersects) {\n                        winding += seg.y1 < seg.y2 ? 1 : -1;\n                    }\n                }\n                return winding !== 0;\n            }\n        }\n        function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (x === void 0) x = 0;\n            if (y === void 0) y = 0;\n            if (channel === void 0) channel = 0;\n            generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n        }\n        function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (x === void 0) x = 0;\n            if (y === void 0) y = 0;\n            if (channel === void 0) channel = 0;\n            var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n            // Expand single-channel data to rbga\n            var rgbaData = new Uint8Array(data.length * 4);\n            for(var i = 0; i < data.length; i++){\n                rgbaData[i * 4 + channel] = data[i];\n            }\n            renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);\n        }\n        /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */ function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n            var ldx = lineX1 - lineX0;\n            var ldy = lineY1 - lineY0;\n            var lengthSq = ldx * ldx + ldy * ldy;\n            var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n            var dx = x - (lineX0 + t * ldx);\n            var dy = y - (lineY0 + t * ldy);\n            return dx * dx + dy * dy;\n        }\n        var javascript = /*#__PURE__*/ Object.freeze({\n            __proto__: null,\n            generate: generate$2,\n            generateIntoCanvas: generateIntoCanvas$2,\n            generateIntoFramebuffer: generateIntoFramebuffer$1\n        });\n        var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n        var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n        var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n        // Single triangle covering viewport\n        var viewportUVs = new Float32Array([\n            0,\n            0,\n            2,\n            0,\n            0,\n            2\n        ]);\n        var implicitContext = null;\n        var isTestingSupport = false;\n        var NULL_OBJECT = {};\n        var supportByCanvas = new WeakMap(); // canvas -> bool\n        function validateSupport(glOrCanvas) {\n            if (!isTestingSupport && !isSupported(glOrCanvas)) {\n                throw new Error(\"WebGL generation not supported\");\n            }\n        }\n        function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (glOrCanvas === void 0) glOrCanvas = null;\n            if (!glOrCanvas) {\n                glOrCanvas = implicitContext;\n                if (!glOrCanvas) {\n                    var canvas = typeof OffscreenCanvas === \"function\" ? new OffscreenCanvas(1, 1) : typeof document !== \"undefined\" ? document.createElement(\"canvas\") : null;\n                    if (!canvas) {\n                        throw new Error(\"OffscreenCanvas or DOM canvas not supported\");\n                    }\n                    glOrCanvas = implicitContext = canvas.getContext(\"webgl\", {\n                        depth: false\n                    });\n                }\n            }\n            validateSupport(glOrCanvas);\n            var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n            // Render into a background texture framebuffer\n            withWebGLContext(glOrCanvas, function(ref) {\n                var gl = ref.gl;\n                var withTexture = ref.withTexture;\n                var withTextureFramebuffer = ref.withTextureFramebuffer;\n                withTexture(\"readable\", function(texture, textureUnit) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                    withTextureFramebuffer(texture, textureUnit, function(framebuffer) {\n                        generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, gl, framebuffer, 0, 0, 0 // red channel\n                        );\n                        gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n                    });\n                });\n            });\n            // Throw away all but the red channel\n            var data = new Uint8Array(sdfWidth * sdfHeight);\n            for(var i = 0, j = 0; i < rgbaData.length; i += 4){\n                data[j++] = rgbaData[i];\n            }\n            return data;\n        }\n        function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (x === void 0) x = 0;\n            if (y === void 0) y = 0;\n            if (channel === void 0) channel = 0;\n            generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n        }\n        function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (x === void 0) x = 0;\n            if (y === void 0) y = 0;\n            if (channel === void 0) channel = 0;\n            // Verify support\n            validateSupport(glOrCanvas);\n            // Compute path segments\n            var lineSegmentCoords = [];\n            pathToLineSegments(path, function(x1, y1, x2, y2) {\n                lineSegmentCoords.push(x1, y1, x2, y2);\n            });\n            lineSegmentCoords = new Float32Array(lineSegmentCoords);\n            withWebGLContext(glOrCanvas, function(ref) {\n                var gl = ref.gl;\n                var isWebGL2 = ref.isWebGL2;\n                var getExtension = ref.getExtension;\n                var withProgram = ref.withProgram;\n                var withTexture = ref.withTexture;\n                var withTextureFramebuffer = ref.withTextureFramebuffer;\n                var handleContextLoss = ref.handleContextLoss;\n                withTexture(\"rawDistances\", function(intermediateTexture, intermediateTextureUnit) {\n                    if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, intermediateTexture._lastWidth = sdfWidth, intermediateTexture._lastHeight = sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                    }\n                    // Unsigned distance pass\n                    withProgram(\"main\", mainVertex, mainFragment, function(ref) {\n                        var setAttribute = ref.setAttribute;\n                        var setUniform = ref.setUniform;\n                        // Init extensions\n                        var instancingExtension = !isWebGL2 && getExtension(\"ANGLE_instanced_arrays\");\n                        var blendMinMaxExtension = !isWebGL2 && getExtension(\"EXT_blend_minmax\");\n                        // Init/update attributes\n                        setAttribute(\"aUV\", 2, gl.STATIC_DRAW, 0, viewportUVs);\n                        setAttribute(\"aLineSegment\", 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n                        // Init/update uniforms\n                        setUniform.apply(void 0, [\n                            \"4f\",\n                            \"uGlyphBounds\"\n                        ].concat(viewBox));\n                        setUniform(\"1f\", \"uMaxDistance\", maxDistance);\n                        setUniform(\"1f\", \"uExponent\", sdfExponent);\n                        // Render initial unsigned distance / winding number info to a texture\n                        withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function(framebuffer) {\n                            gl.enable(gl.BLEND);\n                            gl.colorMask(true, true, true, true);\n                            gl.viewport(0, 0, sdfWidth, sdfHeight);\n                            gl.scissor(0, 0, sdfWidth, sdfHeight);\n                            gl.blendFunc(gl.ONE, gl.ONE);\n                            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n                            // Alpha holds the closest (MAX) unsigned distance.\n                            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n                            gl.clear(gl.COLOR_BUFFER_BIT);\n                            if (isWebGL2) {\n                                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n                            } else {\n                                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n                            }\n                        // Debug\n                        // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n                        // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n                        // console.log('intermediate texture data: ', debug)\n                        });\n                    });\n                    // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n                    withProgram(\"post\", viewportQuadVertex, postFragment, function(program) {\n                        program.setAttribute(\"aUV\", 2, gl.STATIC_DRAW, 0, viewportUVs);\n                        program.setUniform(\"1i\", \"tex\", intermediateTextureUnit);\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n                        gl.disable(gl.BLEND);\n                        gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n                        gl.viewport(x, y, sdfWidth, sdfHeight);\n                        gl.scissor(x, y, sdfWidth, sdfHeight);\n                        gl.drawArrays(gl.TRIANGLES, 0, 3);\n                    });\n                });\n                // Handle context loss occurring during any of the above calls\n                if (gl.isContextLost()) {\n                    handleContextLoss();\n                    throw new Error(\"webgl context lost\");\n                }\n            });\n        }\n        function isSupported(glOrCanvas) {\n            var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;\n            var supported = supportByCanvas.get(key);\n            if (supported === undefined) {\n                isTestingSupport = true;\n                var failReason = null;\n                try {\n                    // Since we can't detect all failure modes up front, let's just do a trial run of a\n                    // simple path and compare what we get back to the correct expected result. This will\n                    // also serve to prime the shader compilation.\n                    var expectedResult = [\n                        97,\n                        106,\n                        97,\n                        61,\n                        99,\n                        137,\n                        118,\n                        80,\n                        80,\n                        118,\n                        137,\n                        99,\n                        61,\n                        97,\n                        106,\n                        97\n                    ];\n                    var testResult = generate$1(4, 4, \"M8,8L16,8L24,24L16,24Z\", [\n                        0,\n                        0,\n                        32,\n                        32\n                    ], 24, 1, glOrCanvas);\n                    supported = testResult && expectedResult.length === testResult.length && testResult.every(function(val, i) {\n                        return val === expectedResult[i];\n                    });\n                    if (!supported) {\n                        failReason = \"bad trial run results\";\n                        console.info(expectedResult, testResult);\n                    }\n                } catch (err) {\n                    // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n                    supported = false;\n                    failReason = err.message;\n                }\n                if (failReason) {\n                    console.warn(\"WebGL SDF generation not supported:\", failReason);\n                }\n                isTestingSupport = false;\n                supportByCanvas.set(key, supported);\n            }\n            return supported;\n        }\n        var webgl = /*#__PURE__*/ Object.freeze({\n            __proto__: null,\n            generate: generate$1,\n            generateIntoCanvas: generateIntoCanvas$1,\n            generateIntoFramebuffer: generateIntoFramebuffer,\n            isSupported: isSupported\n        });\n        /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */ function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n            if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n            if (sdfExponent === void 0) sdfExponent = 1;\n            try {\n                return generate$1.apply(webgl, arguments);\n            } catch (e) {\n                console.info(\"WebGL SDF generation failed, falling back to JS\", e);\n                return generate$2.apply(javascript, arguments);\n            }\n        }\n        /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */ function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n            if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n            if (sdfExponent === void 0) sdfExponent = 1;\n            if (x === void 0) x = 0;\n            if (y === void 0) y = 0;\n            if (channel === void 0) channel = 0;\n            try {\n                return generateIntoCanvas$1.apply(webgl, arguments);\n            } catch (e) {\n                console.info(\"WebGL SDF generation failed, falling back to JS\", e);\n                return generateIntoCanvas$2.apply(javascript, arguments);\n            }\n        }\n        exports.forEachPathCommand = forEachPathCommand;\n        exports.generate = generate;\n        exports.generateIntoCanvas = generateIntoCanvas;\n        exports.javascript = javascript;\n        exports.pathToLineSegments = pathToLineSegments;\n        exports.webgl = webgl;\n        exports.webglUtils = webglUtils;\n        Object.defineProperty(exports, \"__esModule\", {\n            value: true\n        });\n        return exports;\n    }({});\n    return exports;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQTtJQUNULElBQUlDLFVBQVcsU0FBVUEsT0FBTztRQUU5Qjs7R0FFQyxHQUNELFNBQVNDLHVCQUF3QkMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsQ0FBQyxFQUFFQyxRQUFRO1lBQ2xFLElBQUlDLEtBQUssSUFBSUY7WUFDYkMsU0FBU0UsQ0FBQyxHQUFHRCxLQUFLQSxLQUFLUixLQUFLLElBQUlRLEtBQUtGLElBQUlKLEtBQUtJLElBQUlBLElBQUlGO1lBQ3RERyxTQUFTRyxDQUFDLEdBQUdGLEtBQUtBLEtBQUtQLEtBQUssSUFBSU8sS0FBS0YsSUFBSUgsS0FBS0csSUFBSUEsSUFBSUQ7UUFDeEQ7UUFFQTs7R0FFQyxHQUNELFNBQVNNLG1CQUFvQlgsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRU8sRUFBRSxFQUFFQyxFQUFFLEVBQUVQLENBQUMsRUFBRUMsUUFBUTtZQUN0RSxJQUFJQyxLQUFLLElBQUlGO1lBQ2JDLFNBQVNFLENBQUMsR0FBR0QsS0FBS0EsS0FBS0EsS0FBS1IsS0FBSyxJQUFJUSxLQUFLQSxLQUFLRixJQUFJSixLQUFLLElBQUlNLEtBQUtGLElBQUlBLElBQUlGLEtBQUtFLElBQUlBLElBQUlBLElBQUlNO1lBQzFGTCxTQUFTRyxDQUFDLEdBQUdGLEtBQUtBLEtBQUtBLEtBQUtQLEtBQUssSUFBSU8sS0FBS0EsS0FBS0YsSUFBSUgsS0FBSyxJQUFJSyxLQUFLRixJQUFJQSxJQUFJRCxLQUFLQyxJQUFJQSxJQUFJQSxJQUFJTztRQUM1RjtRQUVBOzs7Ozs7Ozs7Ozs7Ozs7R0FlQyxHQUNELFNBQVNDLG1CQUFtQkMsVUFBVSxF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QUMzQyxFQUFFLE9BQU05QixHQUFHO2dCQUNUNE0sUUFBUUMsSUFBSSxDQUFDLG1EQUFtRDdNO2dCQUNoRSxPQUFPK0kscUJBQXFCN0csS0FBSyxDQUFDMEgsWUFBWTlIO1lBQ2hEO1FBQ0Y7UUFFQTFHLFFBQVFnQixrQkFBa0IsR0FBR0E7UUFDN0JoQixRQUFReU8sUUFBUSxHQUFHQTtRQUNuQnpPLFFBQVEwTyxrQkFBa0IsR0FBR0E7UUFDN0IxTyxRQUFRd08sVUFBVSxHQUFHQTtRQUNyQnhPLFFBQVFnQyxrQkFBa0IsR0FBR0E7UUFDN0JoQyxRQUFRNlIsS0FBSyxHQUFHQTtRQUNoQjdSLFFBQVFnTCxVQUFVLEdBQUdBO1FBRXJCQyxPQUFPNkcsY0FBYyxDQUFDOVIsU0FBUyxjQUFjO1lBQUUrUixPQUFPO1FBQUs7UUFFM0QsT0FBTy9SO0lBRVQsRUFBRSxDQUFDO0lBQ0gsT0FBT0E7QUFDUDtBQUVtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2luZWVyaW5nLWNhbGN1bGF0b3IvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzPzBiOWQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gU0RGR2VuZXJhdG9yKCkge1xudmFyIGV4cG9ydHMgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAvKipcbiAgICogRmluZCB0aGUgcG9pbnQgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uUXVhZHJhdGljQmV6aWVyICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0LCBwb2ludE91dCkge1xuICAgIHZhciB0MiA9IDEgLSB0O1xuICAgIHBvaW50T3V0LnggPSB0MiAqIHQyICogeDAgKyAyICogdDIgKiB0ICogeDEgKyB0ICogdCAqIHgyO1xuICAgIHBvaW50T3V0LnkgPSB0MiAqIHQyICogeTAgKyAyICogdDIgKiB0ICogeTEgKyB0ICogdCAqIHkyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uQ3ViaWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdCwgcG9pbnRPdXQpIHtcbiAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHQyICogeDAgKyAzICogdDIgKiB0MiAqIHQgKiB4MSArIDMgKiB0MiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHQyICogeTAgKyAzICogdDIgKiB0MiAqIHQgKiB5MSArIDMgKiB0MiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHBhdGggc3RyaW5nIGludG8gaXRzIGNvbnN0aXR1ZW50IGxpbmUvY3VydmUgY29tbWFuZHMsIGludm9raW5nIGEgY2FsbGJhY2sgZm9yIGVhY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICAgKiAgIGNvbW1hbmQ6ICdMJ3wnUSd8J0MnLFxuICAgKiAgIHN0YXJ0WDogbnVtYmVyLFxuICAgKiAgIHN0YXJ0WTogbnVtYmVyLFxuICAgKiAgIGVuZFg6IG51bWJlcixcbiAgICogICBlbmRZOiBudW1iZXIsXG4gICAqICAgY3RybDFYPzogbnVtYmVyLFxuICAgKiAgIGN0cmwxWT86IG51bWJlcixcbiAgICogICBjdHJsMlg/OiBudW1iZXIsXG4gICAqICAgY3RybDJZPzogbnVtYmVyXG4gICAqICl9IGNvbW1hbmRDYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIHBhcnNlZCBwYXRoIGNvbW1hbmQsIHBhc3NpbmcgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgaWRlbnRpZmllciAob25seSBML1EvQyBjb21tYW5kcykgYW5kIGl0cyBudW1lcmljIGFyZ3VtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBjb21tYW5kQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VnbWVudFJFID0gLyhbTUxRQ1pdKShbXk1MUUNaXSopL2c7XG4gICAgdmFyIG1hdGNoLCBmaXJzdFgsIGZpcnN0WSwgcHJldlgsIHByZXZZO1xuICAgIHdoaWxlICgobWF0Y2ggPSBzZWdtZW50UkUuZXhlYyhwYXRoU3RyaW5nKSkpIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2hbMl1cbiAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKVxuICAgICAgICAuc3BsaXQoL1ssXFxzXSsvKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUZsb2F0KHYpOyB9KTtcbiAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcHJldlggPSBmaXJzdFggPSBhcmdzWzBdO1xuICAgICAgICAgIHByZXZZID0gZmlyc3RZID0gYXJnc1sxXTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBpZiAoYXJnc1swXSAhPT0gcHJldlggfHwgYXJnc1sxXSAhPT0gcHJldlkpIHsgLy8geXVwLCBzb21lIGZvbnRzIGhhdmUgemVyby1sZW5ndGggbGluZSBjb21tYW5kc1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzBdKSwgKHByZXZZID0gYXJnc1sxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnUScsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1syXSksIChwcmV2WSA9IGFyZ3NbM10pLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdDJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzRdKSwgKHByZXZZID0gYXJnc1s1XSksIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgaWYgKHByZXZYICE9PSBmaXJzdFggfHwgcHJldlkgIT09IGZpcnN0WSkge1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCBmaXJzdFgsIGZpcnN0WSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBwYXRoIHN0cmluZyB0byBhIHNlcmllcyBvZiBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHgxOm51bWJlciwgeTE6bnVtYmVyLCB4MjpudW1iZXIsIHkyOm51bWJlcil9IHNlZ21lbnRDYWxsYmFjayAtIEEgY2FsbGJhY2tcbiAgICogICAgICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZXZlcnkgbGluZSBzZWdtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VydmVQb2ludHNdIC0gSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGFcbiAgICogICAgICAgIGJlemllciBjdXJ2ZSBpbiB0aGUgcGF0aC4gRGVmYXVsdHMgdG8gMTYuXG4gICAqL1xuICBmdW5jdGlvbiBwYXRoVG9MaW5lU2VnbWVudHMgKHBhdGhTdHJpbmcsIHNlZ21lbnRDYWxsYmFjaywgY3VydmVQb2ludHMpIHtcbiAgICBpZiAoIGN1cnZlUG9pbnRzID09PSB2b2lkIDAgKSBjdXJ2ZVBvaW50cyA9IDE2O1xuXG4gICAgdmFyIHRlbXBQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBmdW5jdGlvbiAoY29tbWFuZCwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGN0cmwxWCwgY3RybDFZLCBjdHJsMlgsIGN0cmwyWSkge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWCA9IHN0YXJ0WDtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGN1cnZlUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgIHN0YXJ0WCwgc3RhcnRZLFxuICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCwgcHJldkN1cnZlWSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVggPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVkgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVYJDEgPSBzdGFydFg7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVkkMSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBjdXJ2ZVBvaW50czsgaSQxKyspIHtcbiAgICAgICAgICAgIHBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgIGN0cmwxWCwgY3RybDFZLFxuICAgICAgICAgICAgICBjdHJsMlgsIGN0cmwyWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSQxIC8gKGN1cnZlUG9pbnRzIC0gMSksXG4gICAgICAgICAgICAgIHRlbXBQb2ludFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhwcmV2Q3VydmVYJDEsIHByZXZDdXJ2ZVkkMSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVgkMSA9IHRlbXBQb2ludC54O1xuICAgICAgICAgICAgcHJldkN1cnZlWSQxID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciB2aWV3cG9ydFF1YWRWZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhVVY7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2VVY9YVVWO2dsX1Bvc2l0aW9uPXZlYzQobWl4KHZlYzIoLTEuMCksdmVjMigxLjApLGFVViksMC4wLDEuMCk7fVwiO1xuXG4gIHZhciBjb3B5VGV4RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO31cIjtcblxuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIHZhciBnbENvbnRleHRQYXJhbXMgPSB7XG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBsaXR0bGUgaGVscGVyIGxpYnJhcnkgZm9yIFdlYkdMLiBJdCBhc3Npc3RzIHdpdGggc3RhdGUgbWFuYWdlbWVudCBmb3IgYSBHTCBjb250ZXh0LlxuICAgKiBJdCdzIHByZXR0eSB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIG5lZWRzIG9mIHRoaXMgcGFja2FnZSwgbm90IHZlcnkgZ2VuZXJhbC1wdXJwb3NlLlxuICAgKlxuICAgKiBAcGFyYW0geyBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB9IGdsT3JDYW52YXMgLSB0aGUgR0wgY29udGV4dCB0byB3cmFwXG4gICAqIEBwYXJhbSB7ICh7Z2wsIGdldEV4dGVuc2lvbiwgd2l0aFByb2dyYW0sIHdpdGhUZXh0dXJlLCB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLCBoYW5kbGVDb250ZXh0TG9zc30pID0+IHZvaWQgfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gd2l0aFdlYkdMQ29udGV4dCAoZ2xPckNhbnZhcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2wgPSBnbE9yQ2FudmFzLmdldENvbnRleHQgPyBnbE9yQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xDb250ZXh0UGFyYW1zKSA6IGdsT3JDYW52YXM7XG4gICAgdmFyIHdyYXBwZXIgPSBjYWNoZS5nZXQoZ2wpO1xuICAgIGlmICghd3JhcHBlcikge1xuICAgICAgdmFyIGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIHZhciBleHRlbnNpb25zID0ge307XG4gICAgICB2YXIgcHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuICAgICAgdmFyIHRleHR1cmVVbml0ID0gLTE7XG4gICAgICB2YXIgZnJhbWVidWZmZXJTdGFjayA9IFtdO1xuXG4gICAgICBnbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV0gPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigobmFtZSArIFwiIG5vdCBzdXBwb3J0ZWRcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlciAoc3JjLCB0eXBlKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgLy8gY29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gICAgICAgIC8vIGlmICghc3RhdHVzICYmICFnbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpLnRyaW0oKSlcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gc2hhZGVyXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhQcm9ncmFtIChuYW1lLCB2ZXJ0LCBmcmFnLCBmdW5jKSB7XG4gICAgICAgIGlmICghcHJvZ3JhbXNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKHZlcnQsIGdsLlZFUlRFWF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcihmcmFnLCBnbC5GUkFHTUVOVF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgICAgICAgIHByb2dyYW1zW25hbWVdID0ge1xuICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBmdW5jdGlvbiB0cmFuc2FjdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICBmdW5jKHtcbiAgICAgICAgICAgICAgICBzZXRVbmlmb3JtOiBmdW5jdGlvbiBzZXRVbmlmb3JtICh0eXBlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtTG9jID0gdW5pZm9ybXNbbmFtZV0gfHwgKHVuaWZvcm1zW25hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgIGdsWyhcInVuaWZvcm1cIiArIHR5cGUpXS5hcHBseShnbCwgWyB1bmlmb3JtTG9jIF0uY29uY2F0KCB2YWx1ZXMgKSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCBzaXplLCB1c2FnZSwgaW5zdGFuY2luZ0Rpdmlzb3IsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBidWY6IGdsLmNyZWF0ZUJ1ZmZlcigpLCAvLyBUT0RPIHNob3VsZCB3ZSBkZXN0cm95IG91ciBidWZmZXJzP1xuICAgICAgICAgICAgICAgICAgICAgIGxvYzogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmKTtcbiAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ci5sb2MsIHNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJykudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGF0dHIubG9jLCBpbnN0YW5jaW5nRGl2aXNvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gYXR0ci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCB1c2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbXNbbmFtZV0udHJhbnNhY3Rpb24oZnVuYyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRleHR1cmVVbml0Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdO1xuICAgICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIGZ1bmModGV4dHVyZSwgdGV4dHVyZVVuaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRleHR1cmVVbml0LS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciAodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmMpIHtcbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgZnJhbWVidWZmZXJTdGFjay5wdXNoKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZ1bmMoZnJhbWVidWZmZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyU3RhY2tbLS1mcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3NzICgpIHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICBwcm9ncmFtcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnNldChnbCwgd3JhcHBlciA9IHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgICAgIGdldEV4dGVuc2lvbjogZ2V0RXh0ZW5zaW9uLFxuICAgICAgICB3aXRoUHJvZ3JhbTogd2l0aFByb2dyYW0sXG4gICAgICAgIHdpdGhUZXh0dXJlOiB3aXRoVGV4dHVyZSxcbiAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjogd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcixcbiAgICAgICAgaGFuZGxlQ29udGV4dExvc3M6IGhhbmRsZUNvbnRleHRMb3NzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKHdyYXBwZXIpO1xuICB9XG5cblxuICBmdW5jdGlvbiByZW5kZXJJbWFnZURhdGEoZ2xPckNhbnZhcywgaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZnJhbWVidWZmZXIpIHtcbiAgICBpZiAoIGNoYW5uZWxzID09PSB2b2lkIDAgKSBjaGFubmVscyA9IDE1O1xuICAgIGlmICggZnJhbWVidWZmZXIgPT09IHZvaWQgMCApIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgIHdpdGhXZWJHTENvbnRleHQoZ2xPckNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuXG4gICAgICB3aXRoVGV4dHVyZSgnY29weScsIGZ1bmN0aW9uICh0ZXgsIHRleFVuaXQpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZURhdGEpO1xuICAgICAgICB3aXRoUHJvZ3JhbSgnY29weScsIHZpZXdwb3J0UXVhZFZlcnRleCwgY29weVRleEZyYWdtZW50LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcbiAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcblxuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDIsIDAsIDAsIDJdKSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWknLCAnaW1hZ2UnLCB0ZXhVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyIHx8IG51bGwpO1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVscyAmIDgsIGNoYW5uZWxzICYgNCwgY2hhbm5lbHMgJiAyLCBjaGFubmVscyAmIDEpO1xuICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6aW5nIGEgY2FudmFzIGNsZWFycyBpdHMgY29udGVudHM7IHRoaXMgdXRpbGl0eSBjb3BpZXMgdGhlIHByZXZpb3VzIGNvbnRlbnRzIG92ZXIuXG4gICAqIEBwYXJhbSBjYW52YXNcbiAgICogQHBhcmFtIG5ld1dpZHRoXG4gICAqIEBwYXJhbSBuZXdIZWlnaHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nKGNhbnZhcywgbmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB3aXRoV2ViR0xDb250ZXh0KGNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuXG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICAgICAgY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgcmVuZGVySW1hZ2VEYXRhKGdsLCBkYXRhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3ZWJnbFV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB3aXRoV2ViR0xDb250ZXh0OiB3aXRoV2ViR0xDb250ZXh0LFxuICAgIHJlbmRlckltYWdlRGF0YTogcmVuZGVySW1hZ2VEYXRhLFxuICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nOiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZ1xuICB9KTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSQyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICB2YXIgdGV4dHVyZURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG5cbiAgICB2YXIgdmlld0JveFdpZHRoID0gdmlld0JveFsyXSAtIHZpZXdCb3hbMF07XG4gICAgdmFyIHZpZXdCb3hIZWlnaHQgPSB2aWV3Qm94WzNdIC0gdmlld0JveFsxXTtcblxuICAgIC8vIERlY29tcG9zZSBhbGwgcGF0aHMgaW50byBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIGFuZCBhZGQgdGhlbSB0byBhbiBpbmRleFxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIsXG4gICAgICAgIG1pblg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgIG1pblk6IE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgIG1heFg6IE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgIG1heFk6IE1hdGgubWF4KHkxLCB5MilcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBzZWdtZW50cyBieSBtYXhYLCB0aGlzIHdpbGwgbGV0IHVzIHNob3J0LWNpcmN1aXQgc29tZSBsb29wcyBiZWxvd1xuICAgIHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubWF4WCAtIGIubWF4WDsgfSk7XG5cbiAgICAvLyBGb3IgZWFjaCB0YXJnZXQgU0RGIHRleGVsLCBmaW5kIHRoZSBkaXN0YW5jZSBmcm9tIGl0cyBjZW50ZXIgdG8gaXRzIG5lYXJlc3QgbGluZSBzZWdtZW50LFxuICAgIC8vIG1hcCB0aGF0IGRpc3RhbmNlIHRvIGFuIGFscGhhIHZhbHVlLCBhbmQgd3JpdGUgdGhhdCBhbHBoYSB0byB0aGUgdGV4ZWxcbiAgICBmb3IgKHZhciBzZGZYID0gMDsgc2RmWCA8IHNkZldpZHRoOyBzZGZYKyspIHtcbiAgICAgIGZvciAodmFyIHNkZlkgPSAwOyBzZGZZIDwgc2RmSGVpZ2h0OyBzZGZZKyspIHtcbiAgICAgICAgdmFyIHNpZ25lZERpc3QgPSBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlKFxuICAgICAgICAgIHZpZXdCb3hbMF0gKyB2aWV3Qm94V2lkdGggKiAoc2RmWCArIDAuNSkgLyBzZGZXaWR0aCxcbiAgICAgICAgICB2aWV3Qm94WzFdICsgdmlld0JveEhlaWdodCAqIChzZGZZICsgMC41KSAvIHNkZkhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVzZSBhbiBleHBvbmVudGlhbCBzY2FsZSB0byBlbnN1cmUgdGhlIHRleGVscyB2ZXJ5IG5lYXIgdGhlIGdseXBoIHBhdGggaGF2ZSBhZGVxdWF0ZVxuICAgICAgICAvLyBwcmVjaXNpb24sIHdoaWxlIGFsbG93aW5nIHRoZSBkaXN0YW5jZSBmaWVsZCB0byBjb3ZlciB0aGUgZW50aXJlIHRleHR1cmUsIGdpdmVuIHRoYXRcbiAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgOCBiaXRzIGF2YWlsYWJsZS4gRm9ybXVsYSB2aXN1YWxpemVkOiBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdWlhcTVhcWlhbVxuICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnBvdygoMSAtIE1hdGguYWJzKHNpZ25lZERpc3QpIC8gbWF4RGlzdGFuY2UpLCBzZGZFeHBvbmVudCkgLyAyO1xuICAgICAgICBpZiAoc2lnbmVkRGlzdCA8IDApIHtcbiAgICAgICAgICBhbHBoYSA9IDEgLSBhbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGFscGhhICogMjU1KSkpOyAvL2NsYW1wXG4gICAgICAgIHRleHR1cmVEYXRhW3NkZlkgKiBzZGZXaWR0aCArIHNkZlhdID0gYWxwaGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmVEYXRhXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiB4L3ksIHNlYXJjaCB0aGUgaW5kZXggZm9yIHRoZSBjbG9zZXN0IGxpbmUgc2VnbWVudCBhbmQgcmV0dXJuXG4gICAgICogaXRzIHNpZ25lZCBkaXN0YW5jZS4gTmVnYXRpdmUgPSBpbnNpZGUsIHBvc2l0aXZlID0gb3V0c2lkZSwgemVybyA9IG9uIGVkZ2VcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlICh4LCB5KSB7XG4gICAgICB2YXIgY2xvc2VzdERpc3RTcSA9IEluZmluaXR5O1xuICAgICAgdmFyIGNsb3Nlc3REaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnLm1heFggKyBjbG9zZXN0RGlzdCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gYmUgY2xvc2VyLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICBpZiAoeCArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblggJiYgeSAtIGNsb3Nlc3REaXN0IDwgc2VnLm1heFkgJiYgeSArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblkpIHtcbiAgICAgICAgICB2YXIgZGlzdFNxID0gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHNlZy54MSwgc2VnLnkxLCBzZWcueDIsIHNlZy55Mik7XG4gICAgICAgICAgaWYgKGRpc3RTcSA8IGNsb3Nlc3REaXN0U3EpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0U3EgPSBkaXN0U3E7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE1hdGguc3FydChjbG9zZXN0RGlzdFNxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmxpcCB0byBuZWdhdGl2ZSBkaXN0YW5jZSBpZiBpbnNpZGUgdGhlIHBvbHlcbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5KHgsIHkpKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0ID0gLWNsb3Nlc3REaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb3Nlc3REaXN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGxpZXMgaW5zaWRlIG9yIG91dHNpZGUgdGhlIGdseXBoLiBVc2VzIGEgc2ltcGxlXG4gICAgICogd2luZGluZy1udW1iZXIgcmF5IGNhc3RpbmcgYWxnb3JpdGhtIHVzaW5nIGEgcmF5IHBvaW50aW5nIGVhc3QgZnJvbSB0aGUgcG9pbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQb2ludEluUG9seSAoeCwgeSkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWcubWF4WCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gY3Jvc3MsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgIHZhciBpbnRlcnNlY3RzID0gKChzZWcueTEgPiB5KSAhPT0gKHNlZy55MiA+IHkpKSAmJiAoeCA8IChzZWcueDIgLSBzZWcueDEpICogKHkgLSBzZWcueTEpIC8gKHNlZy55MiAtIHNlZy55MSkgKyBzZWcueDEpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgICAgIHdpbmRpbmcgKz0gc2VnLnkxIDwgc2VnLnkyID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZGluZyAhPT0gMFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMShzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgbnVsbCwgeCwgeSwgY2hhbm5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdmFyIGRhdGEgPSBnZW5lcmF0ZSQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCk7XG4gICAgLy8gRXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgdG8gcmJnYVxuICAgIHZhciByZ2JhRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICogNCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JhRGF0YVtpICogNCArIGNoYW5uZWxdID0gZGF0YVtpXTtcbiAgICB9XG4gICAgcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIHJnYmFEYXRhLCB4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCksIGZyYW1lYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQgYXQgY2xvc2VzdCBhcHByb2FjaFxuICAgKi9cbiAgZnVuY3Rpb24gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50ICh4LCB5LCBsaW5lWDAsIGxpbmVZMCwgbGluZVgxLCBsaW5lWTEpIHtcbiAgICB2YXIgbGR4ID0gbGluZVgxIC0gbGluZVgwO1xuICAgIHZhciBsZHkgPSBsaW5lWTEgLSBsaW5lWTA7XG4gICAgdmFyIGxlbmd0aFNxID0gbGR4ICogbGR4ICsgbGR5ICogbGR5O1xuICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgIHZhciBkeCA9IHggLSAobGluZVgwICsgdCAqIGxkeCk7XG4gICAgdmFyIGR5ID0geSAtIChsaW5lWTAgKyB0ICogbGR5KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHlcbiAgfVxuXG4gIHZhciBqYXZhc2NyaXB0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMixcbiAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQyLFxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxXG4gIH0pO1xuXG4gIHZhciBtYWluVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczthdHRyaWJ1dGUgdmVjMiBhVVY7YXR0cmlidXRlIHZlYzQgYUxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjNCB2TGluZVNlZ21lbnQ7dmFyeWluZyB2ZWMyIHZHbHlwaFhZO3ZvaWQgbWFpbigpe3ZMaW5lU2VnbWVudD1hTGluZVNlZ21lbnQ7dkdseXBoWFk9bWl4KHVHbHlwaEJvdW5kcy54eSx1R2x5cGhCb3VuZHMuencsYVVWKTtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICB2YXIgbWFpbkZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczt1bmlmb3JtIGZsb2F0IHVNYXhEaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVFeHBvbmVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTtmbG9hdCBhYnNEaXN0VG9TZWdtZW50KHZlYzIgcG9pbnQsdmVjMiBsaW5lQSx2ZWMyIGxpbmVCKXt2ZWMyIGxpbmVEaXI9bGluZUItbGluZUE7ZmxvYXQgbGVuU3E9ZG90KGxpbmVEaXIsbGluZURpcik7ZmxvYXQgdD1sZW5TcT09MC4wID8gMC4wIDogY2xhbXAoZG90KHBvaW50LWxpbmVBLGxpbmVEaXIpL2xlblNxLDAuMCwxLjApO3ZlYzIgbGluZVB0PWxpbmVBK3QqbGluZURpcjtyZXR1cm4gZGlzdGFuY2UocG9pbnQsbGluZVB0KTt9dm9pZCBtYWluKCl7dmVjNCBzZWc9dkxpbmVTZWdtZW50O3ZlYzIgcD12R2x5cGhYWTtmbG9hdCBkaXN0PWFic0Rpc3RUb1NlZ21lbnQocCxzZWcueHksc2VnLnp3KTtmbG9hdCB2YWw9cG93KDEuMC1jbGFtcChkaXN0L3VNYXhEaXN0YW5jZSwwLjAsMS4wKSx1RXhwb25lbnQpKjAuNTtib29sIGNyb3NzaW5nPShzZWcueT5wLnkhPXNlZy53PnAueSkmJihwLng8KHNlZy56LXNlZy54KSoocC55LXNlZy55KS8oc2VnLnctc2VnLnkpK3NlZy54KTtib29sIGNyb3NzaW5nVXA9Y3Jvc3NpbmcmJnZMaW5lU2VnbWVudC55PHZMaW5lU2VnbWVudC53O2dsX0ZyYWdDb2xvcj12ZWM0KGNyb3NzaW5nVXAgPyAxLjAvMjU1LjAgOiAwLjAsY3Jvc3NpbmcmJiFjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLDAuMCx2YWwpO31cIjtcblxuICB2YXIgcG9zdEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dmVjNCBjb2xvcj10ZXh0dXJlMkQodGV4LHZVVik7Ym9vbCBpbnNpZGU9Y29sb3IuciE9Y29sb3IuZztmbG9hdCB2YWw9aW5zaWRlID8gMS4wLWNvbG9yLmEgOiBjb2xvci5hO2dsX0ZyYWdDb2xvcj12ZWM0KHZhbCk7fVwiO1xuXG4gIC8vIFNpbmdsZSB0cmlhbmdsZSBjb3ZlcmluZyB2aWV3cG9ydFxuICB2YXIgdmlld3BvcnRVVnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG5cbiAgdmFyIGltcGxpY2l0Q29udGV4dCA9IG51bGw7XG4gIHZhciBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gIHZhciBOVUxMX09CSkVDVCA9IHt9O1xuICB2YXIgc3VwcG9ydEJ5Q2FudmFzID0gbmV3IFdlYWtNYXAoKTsgLy8gY2FudmFzIC0+IGJvb2xcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN1cHBvcnQgKGdsT3JDYW52YXMpIHtcbiAgICBpZiAoIWlzVGVzdGluZ1N1cHBvcnQgJiYgIWlzU3VwcG9ydGVkKGdsT3JDYW52YXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggZ2xPckNhbnZhcyA9PT0gdm9pZCAwICkgZ2xPckNhbnZhcyA9IG51bGw7XG5cbiAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQ7XG4gICAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSlcbiAgICAgICAgICA6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNjcmVlbkNhbnZhcyBvciBET00gY2FudmFzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG4gICAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IGRlcHRoOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpOyAvL25vdCBVaW50OENsYW1wZWRBcnJheSwgY3V6IFNhZmFyaVxuXG4gICAgLy8gUmVuZGVyIGludG8gYSBiYWNrZ3JvdW5kIHRleHR1cmUgZnJhbWVidWZmZXJcbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdyZWFkYWJsZScsIGZ1bmN0aW9uICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNkZldpZHRoLCBzZGZIZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKFxuICAgICAgICAgICAgc2RmV2lkdGgsXG4gICAgICAgICAgICBzZGZIZWlnaHQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdmlld0JveCxcbiAgICAgICAgICAgIG1heERpc3RhbmNlLFxuICAgICAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgICAgICBnbCxcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwIC8vIHJlZCBjaGFubmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJnYmFEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aGUgcmVkIGNoYW5uZWxcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCByZ2JhRGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZGF0YVtqKytdID0gcmdiYURhdGFbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcywgZnJhbWVidWZmZXIsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAvLyBWZXJpZnkgc3VwcG9ydFxuICAgIHZhbGlkYXRlU3VwcG9ydChnbE9yQ2FudmFzKTtcblxuICAgIC8vIENvbXB1dGUgcGF0aCBzZWdtZW50c1xuICAgIHZhciBsaW5lU2VnbWVudENvb3JkcyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGxpbmVTZWdtZW50Q29vcmRzLnB1c2goeDEsIHkxLCB4MiwgeTIpO1xuICAgIH0pO1xuICAgIGxpbmVTZWdtZW50Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciBpc1dlYkdMMiA9IHJlZi5pc1dlYkdMMjtcbiAgICAgIHZhciBnZXRFeHRlbnNpb24gPSByZWYuZ2V0RXh0ZW5zaW9uO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgPSByZWYud2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjtcbiAgICAgIHZhciBoYW5kbGVDb250ZXh0TG9zcyA9IHJlZi5oYW5kbGVDb250ZXh0TG9zcztcblxuICAgICAgd2l0aFRleHR1cmUoJ3Jhd0Rpc3RhbmNlcycsIGZ1bmN0aW9uIChpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCkge1xuICAgICAgICBpZiAoc2RmV2lkdGggIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCB8fCBzZGZIZWlnaHQgIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQpIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSxcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCA9IHNkZldpZHRoLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdEhlaWdodCA9IHNkZkhlaWdodCxcbiAgICAgICAgICAgIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5zaWduZWQgZGlzdGFuY2UgcGFzc1xuICAgICAgICB3aXRoUHJvZ3JhbSgnbWFpbicsIG1haW5WZXJ0ZXgsIG1haW5GcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG5cbiAgICAgICAgICAvLyBJbml0IGV4dGVuc2lvbnNcbiAgICAgICAgICB2YXIgaW5zdGFuY2luZ0V4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICB2YXIgYmxlbmRNaW5NYXhFeHRlbnNpb24gPSAhaXNXZWJHTDIgJiYgZ2V0RXh0ZW5zaW9uKCdFWFRfYmxlbmRfbWlubWF4Jyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYUxpbmVTZWdtZW50JywgNCwgZ2wuRFlOQU1JQ19EUkFXLCAxLCBsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSB1bmlmb3Jtc1xuICAgICAgICAgIHNldFVuaWZvcm0uYXBwbHkodm9pZCAwLCBbICc0ZicsICd1R2x5cGhCb3VuZHMnIF0uY29uY2F0KCB2aWV3Qm94ICkpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFmJywgJ3VNYXhEaXN0YW5jZScsIG1heERpc3RhbmNlKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1RXhwb25lbnQnLCBzZGZFeHBvbmVudCk7XG5cbiAgICAgICAgICAvLyBSZW5kZXIgaW5pdGlhbCB1bnNpZ25lZCBkaXN0YW5jZSAvIHdpbmRpbmcgbnVtYmVyIGluZm8gdG8gYSB0ZXh0dXJlXG4gICAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcihpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCwgZnVuY3Rpb24gKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgIC8vIFJlZCtHcmVlbiBjaGFubmVscyBhcmUgaW5jcmVtZW50ZWQgKEZVTkNfQUREKSBmb3Igc2VnbWVudC1yYXkgY3Jvc3NpbmdzIHRvIGdpdmUgYSBcIndpbmRpbmcgbnVtYmVyXCIuXG4gICAgICAgICAgICAvLyBBbHBoYSBob2xkcyB0aGUgY2xvc2VzdCAoTUFYKSB1bnNpZ25lZCBkaXN0YW5jZS5cbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgaXNXZWJHTDIgPyBnbC5NQVggOiBibGVuZE1pbk1heEV4dGVuc2lvbi5NQVhfRVhUKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoZ2wuVFJJQU5HTEVTLCAwLCAzLCBsaW5lU2VnbWVudENvb3Jkcy5sZW5ndGggLyA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNpbmdFeHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWJ1Z1xuICAgICAgICAgICAgLy8gY29uc3QgZGVidWcgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpXG4gICAgICAgICAgICAvLyBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRlYnVnKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSB0ZXh0dXJlIGRhdGE6ICcsIGRlYnVnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2UgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSB0ZXh0dXJlIHRvIGFwcGx5IGluc2lkZS9vdXRzaWRlIGFuZCB3cml0ZSB0byB0aGUgb3V0cHV0IGZyYW1lYnVmZmVyIHJlY3QrY2hhbm5lbC5cbiAgICAgICAgd2l0aFByb2dyYW0oJ3Bvc3QnLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIHBvc3RGcmFnbWVudCwgZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICBwcm9ncmFtLnNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0oJzFpJywgJ3RleCcsIGludGVybWVkaWF0ZVRleHR1cmVVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbCA9PT0gMCwgY2hhbm5lbCA9PT0gMSwgY2hhbm5lbCA9PT0gMiwgY2hhbm5lbCA9PT0gMyk7XG4gICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhhbmRsZSBjb250ZXh0IGxvc3Mgb2NjdXJyaW5nIGR1cmluZyBhbnkgb2YgdGhlIGFib3ZlIGNhbGxzXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2ViZ2wgY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkIChnbE9yQ2FudmFzKSB7XG4gICAgdmFyIGtleSA9ICghZ2xPckNhbnZhcyB8fCBnbE9yQ2FudmFzID09PSBpbXBsaWNpdENvbnRleHQpID8gTlVMTF9PQkpFQ1QgOiAoZ2xPckNhbnZhcy5jYW52YXMgfHwgZ2xPckNhbnZhcyk7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRCeUNhbnZhcy5nZXQoa2V5KTtcbiAgICBpZiAoc3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSB0cnVlO1xuICAgICAgdmFyIGZhaWxSZWFzb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGV0ZWN0IGFsbCBmYWlsdXJlIG1vZGVzIHVwIGZyb250LCBsZXQncyBqdXN0IGRvIGEgdHJpYWwgcnVuIG9mIGFcbiAgICAgICAgLy8gc2ltcGxlIHBhdGggYW5kIGNvbXBhcmUgd2hhdCB3ZSBnZXQgYmFjayB0byB0aGUgY29ycmVjdCBleHBlY3RlZCByZXN1bHQuIFRoaXMgd2lsbFxuICAgICAgICAvLyBhbHNvIHNlcnZlIHRvIHByaW1lIHRoZSBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAgICAgIHZhciBleHBlY3RlZFJlc3VsdCA9IFtcbiAgICAgICAgICA5NywgMTA2LCA5NywgNjEsXG4gICAgICAgICAgOTksIDEzNywgMTE4LCA4MCxcbiAgICAgICAgICA4MCwgMTE4LCAxMzcsIDk5LFxuICAgICAgICAgIDYxLCA5NywgMTA2LCA5N1xuICAgICAgICBdO1xuICAgICAgICB2YXIgdGVzdFJlc3VsdCA9IGdlbmVyYXRlJDEoXG4gICAgICAgICAgNCxcbiAgICAgICAgICA0LFxuICAgICAgICAgICdNOCw4TDE2LDhMMjQsMjRMMTYsMjRaJyxcbiAgICAgICAgICBbMCwgMCwgMzIsIDMyXSxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIGdsT3JDYW52YXNcbiAgICAgICAgKTtcbiAgICAgICAgc3VwcG9ydGVkID0gdGVzdFJlc3VsdCAmJiBleHBlY3RlZFJlc3VsdC5sZW5ndGggPT09IHRlc3RSZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgdGVzdFJlc3VsdC5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB2YWwgPT09IGV4cGVjdGVkUmVzdWx0W2ldOyB9KTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICBmYWlsUmVhc29uID0gJ2JhZCB0cmlhbCBydW4gcmVzdWx0cyc7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGV4cGVjdGVkUmVzdWx0LCB0ZXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRPRE8gaWYgaXQgdGhyZXcgZHVlIHRvIHdlYmdsIGNvbnRleHQgbG9zcywgc2hvdWxkIHdlIG1heWJlIGxlYXZlIGlzU3VwcG9ydGVkIGFzIG51bGwgYW5kIHRyeSBhZ2FpbiBsYXRlcj9cbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZhaWxSZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsUmVhc29uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2ViR0wgU0RGIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZDonLCBmYWlsUmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgICAgIHN1cHBvcnRCeUNhbnZhcy5zZXQoa2V5LCBzdXBwb3J0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkXG4gIH1cblxuICB2YXIgd2ViZ2wgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQxLFxuICAgIGdlbmVyYXRlSW50b0NhbnZhczogZ2VuZXJhdGVJbnRvQ2FudmFzJDEsXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXI6IGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyLFxuICAgIGlzU3VwcG9ydGVkOiBpc1N1cHBvcnRlZFxuICB9KTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBhbiBTVkctbGlrZSBwYXRoIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnbHlwaDsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAqICAgICAgICB0byBoYWxmIHRoZSBtYXhpbXVtIHZpZXdCb3ggZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGUoXG4gICAgc2RmV2lkdGgsXG4gICAgc2RmSGVpZ2h0LFxuICAgIHBhdGgsXG4gICAgdmlld0JveCxcbiAgICBtYXhEaXN0YW5jZSxcbiAgICBzZGZFeHBvbmVudFxuICApIHtcbiAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlJDIuYXBwbHkoamF2YXNjcmlwdCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLCBpbnNlcnRpbmcgdGhlIHJlc3VsdCBpbnRvIGEgV2ViR0wgYGNhbnZhc2AgYXQgYSBnaXZlbiB4L3kgcG9zaXRpb25cbiAgICogYW5kIGNvbG9yIGNoYW5uZWwuIFRoaXMgaXMgZ2VuZXJhbGx5IG11Y2ggZmFzdGVyIHRoYW4gY2FsbGluZyBgZ2VuZXJhdGVgIGJlY2F1c2UgaXQgZG9lcyBub3QgcmVxdWlyZSByZWFkaW5nIHBpeGVsc1xuICAgKiBiYWNrIGZyb20gdGhlIEdQVS0+Q1BVIC0tIHRoZSBgY2FudmFzYCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBhIFdlYkdMIHRleHR1cmUgaW1hZ2UsIHNvIGl0IGFsbCBzdGF5cyBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmV2lkdGggLSB3aWR0aCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHZpZXdCb3ggLSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gaW4gZm9udCB1bml0cyBhbGlnbmluZyB3aXRoIHRoZSB0ZXh0dXJlJ3MgZWRnZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2RmRXhwb25lbnRdIC0gc3BlY2lmaWVzIGFuIGV4cG9uZW50IGZvciBlbmNvZGluZyB0aGUgU0RGJ3MgZGlzdGFuY2UgdmFsdWVzOyBoaWdoZXIgZXhwb25lbnRzXG4gICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSBjYW52YXMgLSBhIFdlYkdMLWVuYWJsZWQgY2FudmFzIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiAgICAgICAgT25seSB0aGUgcmVsZXZhbnQgcmVjdC9jaGFubmVsIHdpbGwgYmUgbW9kaWZpZWQsIHRoZSByZXN0IHdpbGwgYmUgcHJlc2VydmVkLiBUbyBhdm9pZCB1bnByZWRpY3RhYmxlIHJlc3VsdHNcbiAgICogICAgICAgIGR1ZSB0byBzaGFyZWQgR0wgY29udGV4dCBzdGF0ZSwgdGhpcyBjYW52YXMgc2hvdWxkIGJlIGRlZGljYXRlZCB0byB1c2UgYnkgdGhpcyBsaWJyYXJ5IGFsb25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIHRoZSBjb2xvciBjaGFubmVsIGluZGV4ICgwLTQpIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzKFxuICAgIHNkZldpZHRoLFxuICAgIHNkZkhlaWdodCxcbiAgICBwYXRoLFxuICAgIHZpZXdCb3gsXG4gICAgbWF4RGlzdGFuY2UsXG4gICAgc2RmRXhwb25lbnQsXG4gICAgY2FudmFzLFxuICAgIHgsXG4gICAgeSxcbiAgICBjaGFubmVsXG4gICkge1xuICAgIGlmICggbWF4RGlzdGFuY2UgPT09IHZvaWQgMCApIG1heERpc3RhbmNlID0gTWF0aC5tYXgodmlld0JveFsyXSAtIHZpZXdCb3hbMF0sIHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAvIDI7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlSW50b0NhbnZhcyQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmZvckVhY2hQYXRoQ29tbWFuZCA9IGZvckVhY2hQYXRoQ29tbWFuZDtcbiAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICBleHBvcnRzLmdlbmVyYXRlSW50b0NhbnZhcyA9IGdlbmVyYXRlSW50b0NhbnZhcztcbiAgZXhwb3J0cy5qYXZhc2NyaXB0ID0gamF2YXNjcmlwdDtcbiAgZXhwb3J0cy5wYXRoVG9MaW5lU2VnbWVudHMgPSBwYXRoVG9MaW5lU2VnbWVudHM7XG4gIGV4cG9ydHMud2ViZ2wgPSB3ZWJnbDtcbiAgZXhwb3J0cy53ZWJnbFV0aWxzID0gd2ViZ2xVdGlscztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG5yZXR1cm4gZXhwb3J0c1xufVxuXG5leHBvcnQgeyBTREZHZW5lcmF0b3IgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIlNERkdlbmVyYXRvciIsImV4cG9ydHMiLCJwb2ludE9uUXVhZHJhdGljQmV6aWVyIiwieDAiLCJ5MCIsIngxIiwieTEiLCJ4MiIsInkyIiwidCIsInBvaW50T3V0IiwidDIiLCJ4IiwieSIsInBvaW50T25DdWJpY0JlemllciIsIngzIiwieTMiLCJmb3JFYWNoUGF0aENvbW1hbmQiLCJwYXRoU3RyaW5nIiwiY29tbWFuZENhbGxiYWNrIiwic2VnbWVudFJFIiwibWF0Y2giLCJmaXJzdFgiLCJmaXJzdFkiLCJwcmV2WCIsInByZXZZIiwiZXhlYyIsImFyZ3MiLCJyZXBsYWNlIiwic3BsaXQiLCJtYXAiLCJ2IiwicGFyc2VGbG9hdCIsInBhdGhUb0xpbmVTZWdtZW50cyIsInNlZ21lbnRDYWxsYmFjayIsImN1cnZlUG9pbnRzIiwidGVtcFBvaW50IiwiY29tbWFuZCIsInN0YXJ0WCIsInN0YXJ0WSIsImVuZFgiLCJlbmRZIiwiY3RybDFYIiwiY3RybDFZIiwiY3RybDJYIiwiY3RybDJZIiwicHJldkN1cnZlWCIsInByZXZDdXJ2ZVkiLCJpIiwicHJldkN1cnZlWCQxIiwicHJldkN1cnZlWSQxIiwiaSQxIiwidmlld3BvcnRRdWFkVmVydGV4IiwiY29weVRleEZyYWdtZW50IiwiY2FjaGUiLCJXZWFrTWFwIiwiZ2xDb250ZXh0UGFyYW1zIiwicHJlbXVsdGlwbGllZEFscGhhIiwicHJlc2VydmVEcmF3aW5nQnVmZmVyIiwiYW50aWFsaWFzIiwiZGVwdGgiLCJ3aXRoV2ViR0xDb250ZXh0IiwiZ2xPckNhbnZhcyIsImNhbGxiYWNrIiwiZ2wiLCJnZXRDb250ZXh0Iiwid3JhcHBlciIsImdldCIsImlzV2ViR0wyIiwiV2ViR0wyUmVuZGVyaW5nQ29udGV4dCIsImV4dGVuc2lvbnMiLCJwcm9ncmFtcyIsInRleHR1cmVzIiwidGV4dHVyZVVuaXQiLCJmcmFtZWJ1ZmZlclN0YWNrIiwiY2FudmFzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJoYW5kbGVDb250ZXh0TG9zcyIsInByZXZlbnREZWZhdWx0IiwiZ2V0RXh0ZW5zaW9uIiwibmFtZSIsImV4dCIsIkVycm9yIiwiY29tcGlsZVNoYWRlciIsInNyYyIsInR5cGUiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJ3aXRoUHJvZ3JhbSIsInZlcnQiLCJmcmFnIiwiZnVuYyIsImF0dHJpYnV0ZXMiLCJ1bmlmb3JtcyIsInByb2dyYW0iLCJjcmVhdGVQcm9ncmFtIiwiYXR0YWNoU2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsIkZSQUdNRU5UX1NIQURFUiIsImxpbmtQcm9ncmFtIiwidHJhbnNhY3Rpb24iLCJ1c2VQcm9ncmFtIiwic2V0VW5pZm9ybSIsInZhbHVlcyIsImxlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuaWZvcm1Mb2MiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJhcHBseSIsImNvbmNhdCIsInNldEF0dHJpYnV0ZSIsInNpemUiLCJ1c2FnZSIsImluc3RhbmNpbmdEaXZpc29yIiwiZGF0YSIsImF0dHIiLCJidWYiLCJjcmVhdGVCdWZmZXIiLCJsb2MiLCJnZXRBdHRyaWJMb2NhdGlvbiIsImJpbmRCdWZmZXIiLCJBUlJBWV9CVUZGRVIiLCJ2ZXJ0ZXhBdHRyaWJQb2ludGVyIiwiRkxPQVQiLCJlbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSIsInZlcnRleEF0dHJpYkRpdmlzb3IiLCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUiLCJidWZmZXJEYXRhIiwid2l0aFRleHR1cmUiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ0ZXh0dXJlIiwiY3JlYXRlVGV4dHVyZSIsImJpbmRUZXh0dXJlIiwiVEVYVFVSRV8yRCIsInRleFBhcmFtZXRlcmkiLCJURVhUVVJFX01JTl9GSUxURVIiLCJORUFSRVNUIiwiVEVYVFVSRV9NQUdfRklMVEVSIiwid2l0aFRleHR1cmVGcmFtZWJ1ZmZlciIsImZyYW1lYnVmZmVyIiwiY3JlYXRlRnJhbWVidWZmZXIiLCJwdXNoIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJmcmFtZWJ1ZmZlclRleHR1cmUyRCIsIkNPTE9SX0FUVEFDSE1FTlQwIiwiZGVsZXRlRnJhbWVidWZmZXIiLCJzZXQiLCJyZW5kZXJJbWFnZURhdGEiLCJpbWFnZURhdGEiLCJ3aWR0aCIsImhlaWdodCIsImNoYW5uZWxzIiwicmVmIiwidGV4IiwidGV4VW5pdCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsIlNUQVRJQ19EUkFXIiwiRmxvYXQzMkFycmF5IiwiZGlzYWJsZSIsIkJMRU5EIiwiY29sb3JNYXNrIiwidmlld3BvcnQiLCJzY2lzc29yIiwiZHJhd0FycmF5cyIsIlRSSUFOR0xFUyIsInJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJVaW50OEFycmF5IiwicmVhZFBpeGVscyIsIndlYmdsVXRpbHMiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJnZW5lcmF0ZSQyIiwic2RmV2lkdGgiLCJzZGZIZWlnaHQiLCJwYXRoIiwidmlld0JveCIsIm1heERpc3RhbmNlIiwic2RmRXhwb25lbnQiLCJ0ZXh0dXJlRGF0YSIsInZpZXdCb3hXaWR0aCIsInZpZXdCb3hIZWlnaHQiLCJzZWdtZW50cyIsIm1pblgiLCJNYXRoIiwibWluIiwibWluWSIsIm1heFgiLCJtYXgiLCJtYXhZIiwic29ydCIsImEiLCJiIiwic2RmWCIsInNkZlkiLCJzaWduZWREaXN0IiwiZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZSIsImFscGhhIiwicG93IiwiYWJzIiwicm91bmQiLCJjbG9zZXN0RGlzdFNxIiwiSW5maW5pdHkiLCJjbG9zZXN0RGlzdCIsInNlZyIsImRpc3RTcSIsImFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCIsInNxcnQiLCJpc1BvaW50SW5Qb2x5Iiwid2luZGluZyIsImludGVyc2VjdHMiLCJnZW5lcmF0ZUludG9DYW52YXMkMiIsImNoYW5uZWwiLCJnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxIiwicmdiYURhdGEiLCJsaW5lWDAiLCJsaW5lWTAiLCJsaW5lWDEiLCJsaW5lWTEiLCJsZHgiLCJsZHkiLCJsZW5ndGhTcSIsImR4IiwiZHkiLCJqYXZhc2NyaXB0IiwiZ2VuZXJhdGUiLCJnZW5lcmF0ZUludG9DYW52YXMiLCJnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciIsIm1haW5WZXJ0ZXgiLCJtYWluRnJhZ21lbnQiLCJwb3N0RnJhZ21lbnQiLCJ2aWV3cG9ydFVWcyIsImltcGxpY2l0Q29udGV4dCIsImlzVGVzdGluZ1N1cHBvcnQiLCJOVUxMX09CSkVDVCIsInN1cHBvcnRCeUNhbnZhcyIsInZhbGlkYXRlU3VwcG9ydCIsImlzU3VwcG9ydGVkIiwiZ2VuZXJhdGUkMSIsIk9mZnNjcmVlbkNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImoiLCJnZW5lcmF0ZUludG9DYW52YXMkMSIsImxpbmVTZWdtZW50Q29vcmRzIiwiaW50ZXJtZWRpYXRlVGV4dHVyZSIsImludGVybWVkaWF0ZVRleHR1cmVVbml0IiwiX2xhc3RXaWR0aCIsIl9sYXN0SGVpZ2h0IiwiaW5zdGFuY2luZ0V4dGVuc2lvbiIsImJsZW5kTWluTWF4RXh0ZW5zaW9uIiwiRFlOQU1JQ19EUkFXIiwiZW5hYmxlIiwiYmxlbmRGdW5jIiwiT05FIiwiYmxlbmRFcXVhdGlvblNlcGFyYXRlIiwiRlVOQ19BREQiLCJNQVgiLCJNQVhfRVhUIiwiY2xlYXIiLCJDT0xPUl9CVUZGRVJfQklUIiwiZHJhd0FycmF5c0luc3RhbmNlZCIsImRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSIsImlzQ29udGV4dExvc3QiLCJrZXkiLCJzdXBwb3J0ZWQiLCJ1bmRlZmluZWQiLCJmYWlsUmVhc29uIiwiZXhwZWN0ZWRSZXN1bHQiLCJ0ZXN0UmVzdWx0IiwiZXZlcnkiLCJ2YWwiLCJjb25zb2xlIiwiaW5mbyIsImVyciIsIm1lc3NhZ2UiLCJ3YXJuIiwid2ViZ2wiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n");

/***/ })

};
;