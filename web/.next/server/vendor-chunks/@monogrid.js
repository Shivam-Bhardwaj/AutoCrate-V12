"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.1.0\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */ \nconst getBufferForType = (type, width, height)=>{\n    let out;\n    switch(type){\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error(\"Unsupported data type\");\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */ const canReadPixels = (type, renderer, camera, renderTargetOptions)=>{\n    if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        color: 0xffffff\n    }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */ class QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */ constructor(options){\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */ this.render = ()=>{\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            } catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type,\n            colorSpace: this._colorSpace,\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        } else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch(this._type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has(\"EXT_color_buffer_float\") ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            } else {\n                this._supportsReadPixels = false;\n                console.warn(\"This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown\");\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */ static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */ toArray() {\n        if (!this._supportsReadPixels) throw new Error(\"Can't read pixels in this browser\");\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */ toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(// fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */ disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */ dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach((v)=>{\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach((value)=>{\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */ get renderer() {\n        return this._renderer;\n    }\n    /**\n     * The `WebGLRenderTarget` used.\n     */ get renderTarget() {\n        return this._renderTarget;\n    }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n    // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */ get material() {\n        return this._material;\n    }\n    /**\n     *\n     */ get type() {\n        return this._type;\n    }\n    get colorSpace() {\n        return this._colorSpace;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItRHVPUFJHQTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFNFU7QUFFN1UsTUFBTXNCLG1CQUFtQixDQUFDQyxNQUFNQyxPQUFPQztJQUNuQyxJQUFJQztJQUNKLE9BQVFIO1FBQ0osS0FBS0gsbURBQWdCQTtZQUNqQk0sTUFBTSxJQUFJQyxrQkFBa0JILFFBQVFDLFNBQVM7WUFDN0M7UUFDSixLQUFLcEIsZ0RBQWFBO1lBQ2RxQixNQUFNLElBQUlFLFlBQVlKLFFBQVFDLFNBQVM7WUFDdkM7UUFDSixLQUFLTixrREFBZUE7WUFDaEJPLE1BQU0sSUFBSUcsWUFBWUwsUUFBUUMsU0FBUztZQUN2QztRQUNKLEtBQUtQLDJDQUFRQTtZQUNUUSxNQUFNLElBQUlJLFVBQVVOLFFBQVFDLFNBQVM7WUFDckM7UUFDSixLQUFLUiw0Q0FBU0E7WUFDVlMsTUFBTSxJQUFJSyxXQUFXUCxRQUFRQyxTQUFTO1lBQ3RDO1FBQ0osS0FBS1QsMENBQU9BO1lBQ1JVLE1BQU0sSUFBSU0sV0FBV1IsUUFBUUMsU0FBUztZQUN0QztRQUNKLEtBQUtuQiw0Q0FBU0E7WUFDVm9CLE1BQU0sSUFBSU8sYUFBYVQsUUFBUUMsU0FBUztZQUN4QztRQUNKO1lBQ0ksTUFBTSxJQUFJUyxNQUFNO0lBQ3hCO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLElBQUlTO0FBQ0o7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNQyxnQkFBZ0IsQ0FBQ2IsTUFBTWMsVUFBVUMsUUFBUUM7SUFDM0MsSUFBSUoseUJBQXlCSyxXQUN6QixPQUFPTDtJQUNYLE1BQU1NLFNBQVMsSUFBSWhDLG9EQUFpQkEsQ0FBQyxHQUFHLEdBQUc4QjtJQUMzQ0YsU0FBU0ssZUFBZSxDQUFDRDtJQUN6QixNQUFNRSxPQUFPLElBQUlwQyx1Q0FBSUEsQ0FBQyxJQUFJQyxnREFBYUEsSUFBSSxJQUFJYSxvREFBaUJBLENB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SSxDQUFDbkMsTUFBTSxFQUFFLElBQUksQ0FBQ0MsT0FBTztJQUN4RDtJQUNBOztLQUVDLEdBQ0QsSUFBSXBELFNBQVM7UUFBRSxPQUFPLElBQUksQ0FBQ29ELE9BQU87SUFBRTtJQUNwQyxJQUFJcEQsT0FBT21HLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQy9DLE9BQU8sR0FBRytDO1FBQ2YsSUFBSSxDQUFDcEQsYUFBYSxDQUFDdUMsT0FBTyxDQUFDLElBQUksQ0FBQ25DLE1BQU0sRUFBRSxJQUFJLENBQUNDLE9BQU87SUFDeEQ7SUFDQTs7S0FFQyxHQUNELElBQUl4QyxXQUFXO1FBQUUsT0FBTyxJQUFJLENBQUNrQyxTQUFTO0lBQUU7SUFDeEM7O0tBRUMsR0FDRCxJQUFJK0MsZUFBZTtRQUFFLE9BQU8sSUFBSSxDQUFDOUMsYUFBYTtJQUFFO0lBQ2hELElBQUk4QyxhQUFhTSxLQUFLLEVBQUU7UUFDcEIsSUFBSSxDQUFDcEQsYUFBYSxHQUFHb0Q7UUFDckIsSUFBSSxDQUFDaEQsTUFBTSxHQUFHZ0QsTUFBTXBHLEtBQUs7UUFDekIsSUFBSSxDQUFDcUQsT0FBTyxHQUFHK0MsTUFBTW5HLE1BQU07SUFDM0Isa0NBQWtDO0lBQ3RDO0lBQ0E7O0tBRUMsR0FDRCxJQUFJd0IsV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFDMkMsU0FBUztJQUFFO0lBQ3hDOztLQUVDLEdBQ0QsSUFBSXJFLE9BQU87UUFBRSxPQUFPLElBQUksQ0FBQ3VELEtBQUs7SUFBRTtJQUNoQyxJQUFJRSxhQUFhO1FBQUUsT0FBTyxJQUFJLENBQUNELFdBQVc7SUFBRTtBQUNoRDtBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9jcmF0ZS13ZWIvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItRHVPUFJHQTQuanM/YmY3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb25vZ3JpZC9nYWlubWFwLWpzIHYzLjEuMFxuICogV2l0aCDinaTvuI8sIGJ5IE1PTk9HUklEIDxybmRAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IFJHQkFGb3JtYXQsIExpbmVhckZpbHRlciwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgU2NlbmUsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBNZXNoLCBQbGFuZUdlb21ldHJ5LCBXZWJHTFJlbmRlclRhcmdldCwgVVZNYXBwaW5nLCBXZWJHTFJlbmRlcmVyLCBEYXRhVGV4dHVyZSwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIFNoYWRlck1hdGVyaWFsLCBUZXh0dXJlLCBJbnRUeXBlLCBTaG9ydFR5cGUsIEJ5dGVUeXBlLCBVbnNpZ25lZEludFR5cGUsIFVuc2lnbmVkQnl0ZVR5cGUsIE1lc2hCYXNpY01hdGVyaWFsIH0gZnJvbSAndGhyZWUnO1xuXG5jb25zdCBnZXRCdWZmZXJGb3JUeXBlID0gKHR5cGUsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBsZXQgb3V0O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFVuc2lnbmVkQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFVuc2lnbmVkSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBVaW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQnl0ZVR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTaG9ydFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSW50VHlwZTpcbiAgICAgICAgICAgIG91dCA9IG5ldyBJbnQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xubGV0IF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuLyoqXG4gKiBUZXN0IGlmIHRoaXMgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBjYW4gY29ycmVjdGx5IHJlYWQgcGl4ZWxzIGZyb20gdGhlIHNwZWNpZmllZFxuICogUmVuZGVyIHRhcmdldCB0eXBlLlxuICpcbiAqIFJ1bnMgb25seSBvbmNlXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSByZW5kZXJlclxuICogQHBhcmFtIGNhbWVyYVxuICogQHBhcmFtIHJlbmRlclRhcmdldE9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGNhblJlYWRQaXhlbHMgPSAodHlwZSwgcmVuZGVyZXIsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0T3B0aW9ucykgPT4ge1xuICAgIGlmIChfY2FuUmVhZFBpeGVsc1Jlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG4gICAgY29uc3QgdGVzdFJUID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHJlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0ZXN0UlQpO1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYgfSkpO1xuICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHR5cGUsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCk7XG4gICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0ZXN0UlQsIDAsIDAsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCwgb3V0KTtcbiAgICB0ZXN0UlQuZGlzcG9zZSgpO1xuICAgIG1lc2guZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgIF9jYW5SZWFkUGl4ZWxzUmVzdWx0ID0gb3V0WzBdICE9PSAwO1xuICAgIHJldHVybiBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbn07XG4vKipcbiAqIFV0aWxpdHkgY2xhc3MgdXNlZCBmb3IgcmVuZGVyaW5nIGEgdGV4dHVyZSB3aXRoIGEgbWF0ZXJpYWxcbiAqXG4gKiBAY2F0ZWdvcnkgQ29yZVxuICogQGdyb3VwIENvcmVcbiAqL1xuY2xhc3MgUXVhZFJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFF1YWRSZW5kZXJlclxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUGFyYW1ldGVycyBmb3IgdGhpcyBRdWFkUmVuZGVyZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xLCBfcjtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3VwcG9ydHNSZWFkUGl4ZWxzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcnMgdGhlIGlucHV0IHRleHR1cmUgdXNpbmcgdGhlIHNwZWNpZmllZCBtYXRlcmlhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5fcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX3NjZW5lLCB0aGlzLl9jYW1lcmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9IG9wdGlvbnMuY29sb3JTcGFjZTtcbiAgICAgICAgY29uc3QgcnRPcHRpb25zID0ge1xuICAgICAgICAgICAgLy8gZml4ZWQgb3B0aW9uc1xuICAgICAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0LFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAvLyB1c2VyIG9wdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX3R5cGUsIC8vIHNldCBpbiBjbGFzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICBhbmlzb3Ryb3B5OiAoKF9hID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYW5pc290cm9weSkgIT09IHVuZGVmaW5lZCA/IChfYiA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFuaXNvdHJvcHkgOiAxLFxuICAgICAgICAgICAgZ2VuZXJhdGVNaXBtYXBzOiAoKF9jID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2VuZXJhdGVNaXBtYXBzKSAhPT0gdW5kZWZpbmVkID8gKF9kID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2UsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6ICgoX2UgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5tYWdGaWx0ZXIpICE9PSB1bmRlZmluZWQgPyAoX2YgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBtaW5GaWx0ZXI6ICgoX2cgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5taW5GaWx0ZXIpICE9PSB1bmRlZmluZWQgPyAoX2ggPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5taW5GaWx0ZXIgOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBzYW1wbGVzOiAoKF9qID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouc2FtcGxlcykgIT09IHVuZGVmaW5lZCA/IChfayA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnNhbXBsZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3cmFwUzogKChfbCA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLndyYXBTKSAhPT0gdW5kZWZpbmVkID8gKF9tID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20ud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAgICAgICAgICAgd3JhcFQ6ICgoX28gPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby53cmFwVCkgIT09IHVuZGVmaW5lZCA/IChfcCA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWw7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbmRlcmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG9wdGlvbnMucmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IFF1YWRSZW5kZXJlci5pbnN0YW50aWF0ZVJlbmRlcmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2NlbmUgPSBuZXcgU2NlbmUoKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xuICAgICAgICB0aGlzLl9jYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDEwKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLmxlZnQgPSAtMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEucmlnaHQgPSAwLjU7XG4gICAgICAgIHRoaXMuX2NhbWVyYS50b3AgPSAwLjU7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5ib3R0b20gPSAtMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICBpZiAoIWNhblJlYWRQaXhlbHModGhpcy5fdHlwZSwgdGhpcy5fcmVuZGVyZXIsIHRoaXMuX2NhbWVyYSwgcnRPcHRpb25zKSkge1xuICAgICAgICAgICAgbGV0IGFsdGVybmF0aXZlVHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVUeXBlID0gdGhpcy5fcmVuZGVyZXIuZXh0ZW5zaW9ucy5oYXMoJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSA/IEZsb2F0VHlwZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWx0ZXJuYXRpdmVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgcGl4ZWxzIGZyb20gJHt0aGlzLl90eXBlfSBSZW5kZXJUYXJnZXRzLCBzd2l0Y2hpbmcgdG8gJHtGbG9hdFR5cGV9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IGFsdGVybmF0aXZlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGRvcyBub3Qgc3VwcG9ydCB0b0FycmF5IG9yIHRvRGF0YVRleHR1cmUsIGNhbGxzIHRvIHRob3NlIG1ldGhvZHMgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3IgdGhyb3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcXVhZCA9IG5ldyBNZXNoKG5ldyBQbGFuZUdlb21ldHJ5KCksIHRoaXMuX21hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgdGhpcy5fc2NlbmUuYWRkKHRoaXMuX3F1YWQpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHJ0T3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC50ZXh0dXJlLm1hcHBpbmcgPSAoKF9xID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3EubWFwcGluZykgIT09IHVuZGVmaW5lZCA/IChfciA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLm1hcHBpbmcgOiBVVk1hcHBpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhIHRlbXBvcmFyeSByZW5kZXJlclxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaW5zdGFudGlhdGVSZW5kZXJlcigpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKDEyOCwgMTI4KTtcbiAgICAgICAgLy8gcmVuZGVyZXIub3V0cHV0Q29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlXG4gICAgICAgIC8vIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmdcbiAgICAgICAgLy8gcmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMgPSBmYWxzZVxuICAgICAgICAvLyB0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHJlbmRlcmVkIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBicm93c2VyIGNhbm5vdCByZWFkIHBpeGVscyBmcm9tIHRoaXMgUmVuZGVyVGFyZ2V0IHR5cGUuXG4gICAgICogQHJldHVybnMgYSBUeXBlZEFycmF5IGNvbnRhaW5pbmcgUkdCQSB2YWx1ZXMgZnJvbSB0aGlzIHJlbmRlcmVyXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIGNvbnN0IG91dCA9IGdldEJ1ZmZlckZvclR5cGUodGhpcy5fdHlwZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHModGhpcy5fcmVuZGVyVGFyZ2V0LCAwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlYWRQaXhlbCBvcGVyYXRpb24gaW4gdGhlIHJlbmRlclRhcmdldFxuICAgICAqIGFuZCByZXR1cm5zIGEgRGF0YVRleHR1cmUgY29udGFpbmluZyB0aGUgcmVhZCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b0RhdGFUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgRGF0YVRleHR1cmUoXG4gICAgICAgIC8vIGZpeGVkIHZhbHVlc1xuICAgICAgICB0aGlzLnRvQXJyYXkoKSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFJHQkFGb3JtYXQsIHRoaXMuX3R5cGUsIFxuICAgICAgICAvLyB1c2VyIHZhbHVlc1xuICAgICAgICAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcHBpbmcpIHx8IFVWTWFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53cmFwUykgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53cmFwVCkgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYWdGaWx0ZXIpIHx8IExpbmVhckZpbHRlciwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5GaWx0ZXIpIHx8IExpbmVhckZpbHRlciwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmlzb3Ryb3B5KSB8fCAxLCBcbiAgICAgICAgLy8gZml4ZWQgdmFsdWVcbiAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICAvLyBzZXQgdGhpcyBhZnRlcndhcmRzLCB3ZSBjYW4ndCBzZXQgaXQgaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuVmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMpICE9PSB1bmRlZmluZWQgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdXNpbmcgYSBkaXNwb3NhYmxlIHJlbmRlcmVyLCBpdCB3aWxsIGRpc3Bvc2UgaXQuXG4gICAgICovXG4gICAgZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBkaXNwb3NlIG9mICoqYWxsKiogYXNzZXRzIHVzZWQgYnkgdGhpcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3Bvc2VSZW5kZXJUYXJnZXQgd2lsbCBkaXNwb3NlIG9mIHRoZSByZW5kZXJUYXJnZXQgd2hpY2ggd2lsbCBub3QgYmUgdXNhYmxlIGxhdGVyXG4gICAgICogc2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UgcGFzc2VkIHRoZSBgcmVuZGVyVGFyZ2V0LnRleHR1cmVgIHRvIGEgYFBNUkVNR2VuZXJhdG9yYFxuICAgICAqIG9yIGFyZSBvdGhlcndpc2UgZG9uZSB3aXRoIGl0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pIClcbiAgICAgKiAvLyBETyBOT1QgZGlzcG9zZSB0aGUgcmVuZGVyVGFyZ2V0IGhlcmUsXG4gICAgICogLy8gaXQgaXMgdXNlZCBkaXJlY3RseSBpbiB0aGUgbWF0ZXJpYWxcbiAgICAgKiByZXN1bHQuZGlzcG9zZSgpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgKiBjb25zdCBwbXJlbUdlbmVyYXRvciA9IG5ldyBQTVJFTUdlbmVyYXRvciggcmVuZGVyZXIgKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICAgICAqIGNvbnN0IGVudk1hcCA9IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIocmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlKVxuICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnZW9tZXRyeSwgbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHsgZW52TWFwIH0pIClcbiAgICAgKiAvLyByZW5kZXJUYXJnZXQgY2FuIGJlIGRpc3Bvc2VkIGhlcmVcbiAgICAgKiAvLyBiZWNhdXNlIGl0IHdhcyB1c2VkIHRvIGdlbmVyYXRlIGEgUE1SRU0gdGV4dHVyZVxuICAgICAqIHJlc3VsdC5kaXNwb3NlKHRydWUpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGlzcG9zZShkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgaWYgKGRpc3Bvc2VSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNwb3NlIHNoYWRlciBtYXRlcmlhbCB0ZXh0dXJlIHVuaWZvcm1zXG4gICAgICAgIGlmICh0aGlzLm1hdGVyaWFsIGluc3RhbmNlb2YgU2hhZGVyTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbC51bmlmb3JtcykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodi52YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpXG4gICAgICAgICAgICAgICAgICAgIHYudmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcG9zZSBvdGhlciBtYXRlcmlhbCBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbCkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgICAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9xdWFkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93aWR0aDsgfVxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2hlaWdodDsgfVxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdXNlZFxuICAgICAqL1xuICAgIGdldCByZW5kZXJlcigpIHsgcmV0dXJuIHRoaXMuX3JlbmRlcmVyOyB9XG4gICAgLyoqXG4gICAgICogVGhlIGBXZWJHTFJlbmRlclRhcmdldGAgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyVGFyZ2V0KCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0OyB9XG4gICAgc2V0IHJlbmRlclRhcmdldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZS53aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUuaGVpZ2h0O1xuICAgICAgICAvLyB0aGlzLl90eXBlID0gdmFsdWUudGV4dHVyZS50eXBlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgTWF0ZXJpYWxgIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IG1hdGVyaWFsKCkgeyByZXR1cm4gdGhpcy5fbWF0ZXJpYWw7IH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuICAgIGdldCBjb2xvclNwYWNlKCkgeyByZXR1cm4gdGhpcy5fY29sb3JTcGFjZTsgfVxufVxuXG5leHBvcnQgeyBRdWFkUmVuZGVyZXIgYXMgUSB9O1xuIl0sIm5hbWVzIjpbIlJHQkFGb3JtYXQiLCJMaW5lYXJGaWx0ZXIiLCJDbGFtcFRvRWRnZVdyYXBwaW5nIiwiU2NlbmUiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiTWVzaCIsIlBsYW5lR2VvbWV0cnkiLCJXZWJHTFJlbmRlclRhcmdldCIsIlVWTWFwcGluZyIsIldlYkdMUmVuZGVyZXIiLCJEYXRhVGV4dHVyZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwiU2hhZGVyTWF0ZXJpYWwiLCJUZXh0dXJlIiwiSW50VHlwZSIsIlNob3J0VHlwZSIsIkJ5dGVUeXBlIiwiVW5zaWduZWRJbnRUeXBlIiwiVW5zaWduZWRCeXRlVHlwZSIsIk1lc2hCYXNpY01hdGVyaWFsIiwiZ2V0QnVmZmVyRm9yVHlwZSIsInR5cGUiLCJ3aWR0aCIsImhlaWdodCIsIm91dCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRXJyb3IiLCJfY2FuUmVhZFBpeGVsc1Jlc3VsdCIsImNhblJlYWRQaXhlbHMiLCJyZW5kZXJlciIsImNhbWVyYSIsInJlbmRlclRhcmdldE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJ0ZXN0UlQiLCJzZXRSZW5kZXJUYXJnZXQiLCJtZXNoIiwiY29sb3IiLCJyZW5kZXIiLCJyZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzIiwiZGlzcG9zZSIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJRdWFkUmVuZGVyZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbyIsIl9wIiwiX3EiLCJfciIsIl9yZW5kZXJlcklzRGlzcG9zYWJsZSIsIl9zdXBwb3J0c1JlYWRQaXhlbHMiLCJfcmVuZGVyZXIiLCJfcmVuZGVyVGFyZ2V0IiwiX3NjZW5lIiwiX2NhbWVyYSIsImUiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX3R5cGUiLCJfY29sb3JTcGFjZSIsImNvbG9yU3BhY2UiLCJydE9wdGlvbnMiLCJmb3JtYXQiLCJkZXB0aEJ1ZmZlciIsInN0ZW5jaWxCdWZmZXIiLCJhbmlzb3Ryb3B5IiwiZ2VuZXJhdGVNaXBtYXBzIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwic2FtcGxlcyIsIndyYXBTIiwid3JhcFQiLCJfbWF0ZXJpYWwiLCJpbnN0YW50aWF0ZVJlbmRlcmVyIiwicG9zaXRpb24iLCJzZXQiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYWx0ZXJuYXRpdmVUeXBlIiwiZXh0ZW5zaW9ucyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiX3F1YWQiLCJjb21wdXRlQm91bmRpbmdCb3giLCJhZGQiLCJ0ZXh0dXJlIiwibWFwcGluZyIsInNldFNpemUiLCJ0b0FycmF5IiwidG9EYXRhVGV4dHVyZSIsInJldHVyblZhbHVlIiwiZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIiLCJmb3JjZUNvbnRleHRMb3NzIiwiZGlzcG9zZVJlbmRlclRhcmdldCIsInJlbmRlclRhcmdldCIsIk9iamVjdCIsInZhbHVlcyIsInVuaWZvcm1zIiwiZm9yRWFjaCIsInYiLCJ2YWx1ZSIsIlEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   MPFExtractor: () => (/* binding */ MPFExtractor),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_DuOPRGA4_js__WEBPACK_IMPORTED_MODULE_1__.Q),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* binding */ extractGainmapFromJPEG),\n/* harmony export */   extractXMP: () => (/* binding */ extractXMP)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_DuOPRGA4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QuadRenderer-DuOPRGA4.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.1.0\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */ \n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */ class GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n     *\n     * @param params\n     */ constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }){\n        super({\n            name: \"GainMapDecoderMaterial\",\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: {\n                    value: sdr\n                },\n                gainMap: {\n                    value: gainMap\n                },\n                gamma: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n                },\n                offsetHdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetHdr)\n                },\n                offsetSdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetSdr)\n                },\n                gainMapMin: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMin)\n                },\n                gainMapMax: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMax)\n                },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() {\n        return this.uniforms.sdr.value;\n    }\n    set sdr(value) {\n        this.uniforms.sdr.value = value;\n    }\n    get gainMap() {\n        return this.uniforms.gainMap.value;\n    }\n    set gainMap(value) {\n        this.uniforms.gainMap.value = value;\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */ get offsetHdr() {\n        return this.uniforms.offsetHdr.value.toArray();\n    }\n    set offsetHdr(value) {\n        this.uniforms.offsetHdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */ get offsetSdr() {\n        return this.uniforms.offsetSdr.value.toArray();\n    }\n    set offsetSdr(value) {\n        this.uniforms.offsetSdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */ get gainMapMin() {\n        return this.uniforms.gainMapMin.value.toArray();\n    }\n    set gainMapMin(value) {\n        this.uniforms.gainMapMin.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */ get gainMapMax() {\n        return this.uniforms.gainMapMax.value.toArray();\n    }\n    set gainMapMax(value) {\n        this.uniforms.gainMapMax.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */ get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [\n            1 / g.x,\n            1 / g.y,\n            1 / g.z\n        ];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMin() {\n        return this._hdrCapacityMin;\n    }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMax() {\n        return this._hdrCapacityMax;\n    }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */ get maxDisplayBoost() {\n        return this._maxDisplayBoost;\n    }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */ const decode = (params)=>{\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        console.warn(\"SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically\");\n        sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n        console.warn(\"Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically\");\n        gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new _QuadRenderer_DuOPRGA4_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n        colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\nclass GainMapNotFoundError extends Error {\n}\nclass XMPMetadataNotFoundError extends Error {\n}\nconst getXMLValue = (xml, tag, defaultValue)=>{\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, \"i\").exec(xml);\n    if (attributeMatch) return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, \"i\").exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map((v)=>v.replace(/<\\/?rdf:li>/g, \"\"));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined) return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input)=>{\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== \"undefined\") str = new TextDecoder().decode(input);\n    else str = input.toString();\n    let start = str.indexOf(\"<x:xmpmeta\");\n    while(start !== -1){\n        const end = str.indexOf(\"x:xmpmeta>\", start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, \"hdrgm:GainMapMin\", \"0\");\n            const gainMapMax = getXMLValue(xmpBlock, \"hdrgm:GainMapMax\");\n            const gamma = getXMLValue(xmpBlock, \"hdrgm:Gamma\", \"1\");\n            const offsetSDR = getXMLValue(xmpBlock, \"hdrgm:OffsetSDR\", \"0.015625\");\n            const offsetHDR = getXMLValue(xmpBlock, \"hdrgm:OffsetHDR\", \"0.015625\");\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : \"0\";\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch) throw new Error(\"Incomplete gainmap metadata\");\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin)\n                ],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax)\n                ],\n                gamma: Array.isArray(gamma) ? gamma.map((v)=>parseFloat(v)) : [\n                    parseFloat(gamma),\n                    parseFloat(gamma),\n                    parseFloat(gamma)\n                ],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR)\n                ],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR)\n                ],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        } catch (e) {\n        // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf(\"<x:xmpmeta\", end);\n    }\n};\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */ class MPFExtractor {\n    constructor(options){\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject)=>{\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error(\"Not a valid jpeg\"));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while(offset < length){\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug) console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug) console.log(\"Found APP2 marker (0xffe2)\");\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */ if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        } else {\n                            reject(new Error(\"No valid endianness marker found in TIFF header\"));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error(\"Not valid TIFF data! (no 0x002A marker)\"));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error(\"Not valid TIFF data! (First offset less than 8)\"));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for(let i = entriesStart; i < entriesStart + 12 * count; i += 12){\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for(let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16){\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            } else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([\n                                dataView\n                            ]);\n                            const imgs = [];\n                            for (const image of images){\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, \"image/jpeg\");\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */ const extractGainmapFromJPEG = async (jpegFile)=>{\n    const metadata = extractXMP(jpegFile);\n    if (!metadata) throw new XMPMetadataNotFoundError(\"Gain map XMP metadata not found\");\n    const mpfExtractor = new MPFExtractor({\n        extractFII: true,\n        extractNonFII: true\n    });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2) throw new GainMapNotFoundError(\"Gain map recovery image not found\");\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */ const getHTMLImageFromBlob = (blob)=>{\n    return new Promise((resolve, reject)=>{\n        const img = document.createElement(\"img\");\n        img.onload = ()=>{\n            resolve(img);\n        };\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = URL.createObjectURL(blob);\n    });\n};\nclass LoaderBase extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */ constructor(renderer, manager){\n        super(manager);\n        if (renderer) this._renderer = renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */ setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */ setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */ prepareQuadRenderer() {\n        if (!this._renderer) console.warn(\"WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.\");\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [\n                1,\n                1,\n                1\n            ],\n            gainMapMin: [\n                0,\n                0,\n                0\n            ],\n            gamma: [\n                1,\n                1,\n                1\n            ],\n            offsetHdr: [\n                1,\n                1,\n                1\n            ],\n            offsetSdr: [\n                1,\n                1,\n                1\n            ],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return new _QuadRenderer_DuOPRGA4_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */ async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([\n            gainMapBuffer\n        ], {\n            type: \"image/jpeg\"\n        }) : undefined;\n        const sdrBlob = new Blob([\n            sdrBuffer\n        ], {\n            type: \"image/jpeg\"\n        });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === \"undefined\") {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        } else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, {\n                    imageOrientation: \"flipY\"\n                }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, {\n                    imageOrientation: \"flipY\"\n                })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */ load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async ()=>{\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                } catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === \"function\") onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === \"function\") onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = ()=>{\n            if (typeof onProgress === \"function\") {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent(\"progress\", {\n                    lengthComputable,\n                    loaded,\n                    total\n                }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType(\"arraybuffer\");\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid sdr buffer\");\n            sdr = buffer;\n            await loadCheck();\n        }, (e)=>{\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType(\"arraybuffer\");\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid gainmap buffer\");\n            gainMap = buffer;\n            await loadCheck();\n        }, (e)=>{\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof json !== \"string\") throw new Error(\"Invalid metadata string\");\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e)=>{\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */ load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof jpeg === \"string\") throw new Error(\"Invalid buffer, received [string], was expecting [ArrayBuffer]\");\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            } catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [\n                            0,\n                            0,\n                            0\n                        ],\n                        gainMapMax: [\n                            1,\n                            1,\n                            1\n                        ],\n                        gamma: [\n                            1,\n                            1,\n                            1\n                        ],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [\n                            0,\n                            0,\n                            0\n                        ],\n                        offsetSdr: [\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                    sdrJPEG = jpegBuffer;\n                } else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            } catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === \"function\") onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === \"function\") onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error)=>{\n            this.manager.itemError(url);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFOEQ7QUFDcU07QUFFcFEsTUFBTWtCLGVBQWUsUUFBUSxHQUFHLENBQUM7Ozs7Ozs7QUFPakMsQ0FBQztBQUNELE1BQU1DLGlCQUFpQixRQUFRLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQm5DLENBQUM7QUFDRDs7Ozs7Q0FLQyxHQUNELE1BQU1DLCtCQUErQmxCLGlEQUFjQTtJQUMvQzs7O0tBR0MsR0FDRG1CLFlBQVksRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxVQUFVLEVBQUVDLGVBQWUsRUFBRUMsY0FBYyxFQUFFQyxjQUFjLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFLENBQUU7UUFDaEksS0FBSyxDQUFDO1lBQ0ZDLE1BQU07WUFDTmQ7WUFDQUM7WUFDQWMsVUFBVTtnQkFDTkgsS0FBSztvQkFBRUksT0FBT0o7Z0JBQUk7Z0JBQ2xCQyxTQUFTO29CQUFFRyxPQUFPSDtnQkFBUTtnQkFDMUJULE9BQU87b0JBQUVZLE9BQU8sSUFBSS9CLDBDQUFPQSxDQUFDLE1BQU1tQixLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU1BLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTUEsS0FBSyxDQUFDLEVBQUU7Z0JBQUU7Z0JBQzVFQyxXQUFXO29CQUFFVyxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1o7Z0JBQVc7Z0JBQ3ZEQyxXQUFXO29CQUFFVSxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1g7Z0JBQVc7Z0JBQ3ZEQyxZQUFZO29CQUFFUyxPQUFPLElBQUkvQiwwQ0FBT0EsR0FBR2dDLFNBQVMsQ0FBQ1Y7Z0JBQVk7Z0JBQ3pEQyxZQUFZO29CQUFFUSxPQUFPLElBQUkvQiwwQ0FBT0Es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QUFFO3dCQUNoQk0sZ0JBQWdCO3dCQUNoQkMsZ0JBQWdCO3dCQUNoQk4sV0FBVzs0QkFBQzs0QkFBRzs0QkFBRzt5QkFBRTt3QkFDcEJDLFdBQVc7NEJBQUM7NEJBQUc7NEJBQUc7eUJBQUU7b0JBQ3hCO29CQUNBa04sVUFBVUQ7Z0JBQ2QsT0FDSztvQkFDRCxNQUFNbks7Z0JBQ1Y7WUFDSjtZQUNBLGFBQWE7WUFDYixJQUFJO2dCQUNBLE1BQU0sSUFBSSxDQUFDRCxNQUFNLENBQUNOLGNBQWMwRixVQUFVaUYsU0FBU0M7WUFDdkQsRUFDQSxPQUFPckMsT0FBTztnQkFDVixJQUFJLENBQUM5QixPQUFPLENBQUMrQixTQUFTLENBQUMrQjtnQkFDdkIsSUFBSSxPQUFPbEMsWUFBWSxZQUNuQkEsUUFBUUU7Z0JBQ1p2SSxhQUFhUSx1QkFBdUI7Z0JBQ3BDO1lBQ0o7WUFDQSxJQUFJLE9BQU8ySCxXQUFXLFlBQ2xCQSxPQUFPbkk7WUFDWCxJQUFJLENBQUN5RyxPQUFPLENBQUNnQyxPQUFPLENBQUM4QjtZQUNyQnZLLGFBQWFRLHVCQUF1QjtRQUN4QyxHQUFHNEgsWUFBWSxDQUFDRztZQUNaLElBQUksQ0FBQzlCLE9BQU8sQ0FBQytCLFNBQVMsQ0FBQytCO1lBQ3ZCLElBQUksT0FBT2xDLFlBQVksWUFDbkJBLFFBQVFFO1FBQ2hCO1FBQ0EsT0FBT3ZJO0lBQ1g7QUFDSjtBQUVvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2F1dG9jcmF0ZS13ZWIvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanM/YTFmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb25vZ3JpZC9nYWlubWFwLWpzIHYzLjEuMFxuICogV2l0aCDinaTvuI8sIGJ5IE1PTk9HUklEIDxybmRAbW9ub2dyaWQuY29tPlxuICovXG5cbmltcG9ydCB7IFEgYXMgUXVhZFJlbmRlcmVyIH0gZnJvbSAnLi9RdWFkUmVuZGVyZXItRHVPUFJHQTQuanMnO1xuaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwsIFZlY3RvcjMsIE5vQmxlbmRpbmcsIFNSR0JDb2xvclNwYWNlLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSwgSGFsZkZsb2F0VHlwZSwgTG9hZGVyLCBMb2FkaW5nTWFuYWdlciwgVGV4dHVyZSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgRmlsZUxvYWRlciB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgdmVydGV4U2hhZGVyID0gLyogZ2xzbCAqLyBgXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZVdiA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xufVxuYDtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gLyogZ2xzbCAqLyBgXG4vLyBtaW4gaGFsZiBmbG9hdCB2YWx1ZVxuI2RlZmluZSBIQUxGX0ZMT0FUX01JTiB2ZWMzKCAtNjU1MDQsIC02NTUwNCwgLTY1NTA0IClcbi8vIG1heCBoYWxmIGZsb2F0IHZhbHVlXG4jZGVmaW5lIEhBTEZfRkxPQVRfTUFYIHZlYzMoIDY1NTA0LCA2NTUwNCwgNjU1MDQgKVxuXG51bmlmb3JtIHNhbXBsZXIyRCBzZHI7XG51bmlmb3JtIHNhbXBsZXIyRCBnYWluTWFwO1xudW5pZm9ybSB2ZWMzIGdhbW1hO1xudW5pZm9ybSB2ZWMzIG9mZnNldEhkcjtcbnVuaWZvcm0gdmVjMyBvZmZzZXRTZHI7XG51bmlmb3JtIHZlYzMgZ2Fpbk1hcE1pbjtcbnVuaWZvcm0gdmVjMyBnYWluTWFwTWF4O1xudW5pZm9ybSBmbG9hdCB3ZWlnaHRGYWN0b3I7XG5cbnZhcnlpbmcgdmVjMiB2VXY7XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjMyByZ2IgPSB0ZXh0dXJlMkQoIHNkciwgdlV2ICkucmdiO1xuICB2ZWMzIHJlY292ZXJ5ID0gdGV4dHVyZTJEKCBnYWluTWFwLCB2VXYgKS5yZ2I7XG4gIHZlYzMgbG9nUmVjb3ZlcnkgPSBwb3coIHJlY292ZXJ5LCBnYW1tYSApO1xuICB2ZWMzIGxvZ0Jvb3N0ID0gZ2Fpbk1hcE1pbiAqICggMS4wIC0gbG9nUmVjb3ZlcnkgKSArIGdhaW5NYXBNYXggKiBsb2dSZWNvdmVyeTtcbiAgdmVjMyBoZHJDb2xvciA9IChyZ2IgKyBvZmZzZXRTZHIpICogZXhwMiggbG9nQm9vc3QgKiB3ZWlnaHRGYWN0b3IgKSAtIG9mZnNldEhkcjtcbiAgdmVjMyBjbGFtcGVkSGRyQ29sb3IgPSBtYXgoIEhBTEZfRkxPQVRfTUlOLCBtaW4oIEhBTEZfRkxPQVRfTUFYLCBoZHJDb2xvciApKTtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggY2xhbXBlZEhkckNvbG9yICwgMS4wICk7XG59XG5gO1xuLyoqXG4gKiBBIE1hdGVyaWFsIHdoaWNoIGlzIGFibGUgdG8gZGVjb2RlIHRoZSBHYWlubWFwIGludG8gYSBmdWxsIEhEUiBSZXByZXNlbnRhdGlvblxuICpcbiAqIEBjYXRlZ29yeSBNYXRlcmlhbHNcbiAqIEBncm91cCBNYXRlcmlhbHNcbiAqL1xuY2xhc3MgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGdhbW1hLCBvZmZzZXRIZHIsIG9mZnNldFNkciwgZ2Fpbk1hcE1pbiwgZ2Fpbk1hcE1heCwgbWF4RGlzcGxheUJvb3N0LCBoZHJDYXBhY2l0eU1pbiwgaGRyQ2FwYWNpdHlNYXgsIHNkciwgZ2Fpbk1hcCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdHYWluTWFwRGVjb2Rlck1hdGVyaWFsJyxcbiAgICAgICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyLFxuICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICBzZHI6IHsgdmFsdWU6IHNkciB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXA6IHsgdmFsdWU6IGdhaW5NYXAgfSxcbiAgICAgICAgICAgICAgICBnYW1tYTogeyB2YWx1ZTogbmV3IFZlY3RvcjMoMS4wIC8gZ2FtbWFbMF0sIDEuMCAvIGdhbW1hWzFdLCAxLjAgLyBnYW1tYVsyXSkgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KG9mZnNldEhkcikgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KG9mZnNldFNkcikgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWluOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWluKSB9LFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGdhaW5NYXBNYXgpIH0sXG4gICAgICAgICAgICAgICAgd2VpZ2h0RmFjdG9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoTWF0aC5sb2cyKG1heERpc3BsYXlCb29zdCkgLSBoZHJDYXBhY2l0eU1pbikgLyAoaGRyQ2FwYWNpdHlNYXggLSBoZHJDYXBhY2l0eU1pbilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmxlbmRpbmc6IE5vQmxlbmRpbmcsXG4gICAgICAgICAgICBkZXB0aFRlc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVwdGhXcml0ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IG1heERpc3BsYXlCb29zdDtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNaW4gPSBoZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSBoZHJDYXBhY2l0eU1heDtcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMudW5pZm9ybXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlOyB9XG4gICAgc2V0IHNkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLnNkci52YWx1ZSA9IHZhbHVlOyB9XG4gICAgZ2V0IGdhaW5NYXAoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWU7IH1cbiAgICBzZXQgZ2Fpbk1hcCh2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWUgPSB2YWx1ZTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5vZmZzZXRIZHJ9XG4gICAgICovXG4gICAgZ2V0IG9mZnNldEhkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0SGRyLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBvZmZzZXRIZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5vZmZzZXRTZHJ9XG4gICAgICovXG4gICAgZ2V0IG9mZnNldFNkcigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBvZmZzZXRTZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5vZmZzZXRTZHIudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYWluTWFwTWlufVxuICAgICAqL1xuICAgIGdldCBnYWluTWFwTWluKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWluLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBnYWluTWFwTWluKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1pbi52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhaW5NYXBNYXh9XG4gICAgICovXG4gICAgZ2V0IGdhaW5NYXBNYXgoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNYXgudmFsdWUudG9BcnJheSgpOyB9XG4gICAgc2V0IGdhaW5NYXBNYXgodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2FtbWF9XG4gICAgICovXG4gICAgZ2V0IGdhbW1hKCkge1xuICAgICAgICBjb25zdCBnID0gdGhpcy51bmlmb3Jtcy5nYW1tYS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIFsxIC8gZy54LCAxIC8gZy55LCAxIC8gZy56XTtcbiAgICB9XG4gICAgc2V0IGdhbW1hKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICBnLnggPSAxLjAgLyB2YWx1ZVswXTtcbiAgICAgICAgZy55ID0gMS4wIC8gdmFsdWVbMV07XG4gICAgICAgIGcueiA9IDEuMCAvIHZhbHVlWzJdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgaGRyQ2FwYWNpdHlNaW4oKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1pbjsgfVxuICAgIHNldCBoZHJDYXBhY2l0eU1pbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1pbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICogQHJlbWFya3MgTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgaGRyQ2FwYWNpdHlNYXgoKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1heDsgfVxuICAgIHNldCBoZHJDYXBhY2l0eU1heCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1heCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWlubWFwRGVjb2RpbmdQYXJhbWV0ZXJzLm1heERpc3BsYXlCb29zdH1cbiAgICAgKiBAcmVtYXJrcyBOb24gTG9nYXJpdGhtaWMgc3BhY2VcbiAgICAgKi9cbiAgICBnZXQgbWF4RGlzcGxheUJvb3N0KCkgeyByZXR1cm4gdGhpcy5fbWF4RGlzcGxheUJvb3N0OyB9XG4gICAgc2V0IG1heERpc3BsYXlCb29zdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXhEaXNwbGF5Qm9vc3QgPSBNYXRoLm1heCgxLCBNYXRoLm1pbig2NTUwNCwgdmFsdWUpKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlV2VpZ2h0KCkge1xuICAgICAgICBjb25zdCB2YWwgPSAoTWF0aC5sb2cyKHRoaXMuX21heERpc3BsYXlCb29zdCkgLSB0aGlzLl9oZHJDYXBhY2l0eU1pbikgLyAodGhpcy5faGRyQ2FwYWNpdHlNYXggLSB0aGlzLl9oZHJDYXBhY2l0eU1pbik7XG4gICAgICAgIHRoaXMudW5pZm9ybXMud2VpZ2h0RmFjdG9yLnZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIERlY29kZXMgYSBnYWluIG1hcCB1c2luZyBhIFdlYkdMUmVuZGVyVGFyZ2V0XG4gKlxuICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGRlY29kZSB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgVGV4dHVyZUxvYWRlcixcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKVxuICpcbiAqIC8vIGxvYWQgU0RSIFJlcHJlc2VudGF0aW9uXG4gKiBjb25zdCBzZHIgPSBhd2FpdCB0ZXh0dXJlTG9hZGVyLmxvYWRBc3luYygnc2RyLmpwZycpXG4gKiAvLyBsb2FkIEdhaW4gbWFwIHJlY292ZXJ5IGltYWdlXG4gKiBjb25zdCBnYWluTWFwID0gYXdhaXQgdGV4dHVyZUxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBnJylcbiAqIC8vIGxvYWQgbWV0YWRhdGFcbiAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgKGF3YWl0IGZldGNoKCdtZXRhZGF0YS5qc29uJykpLmpzb24oKVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY29kZSh7XG4gKiAgIHNkcixcbiAqICAgZ2Fpbk1hcCxcbiAqICAgLy8gdGhpcyBhbGxvd3MgdG8gdXNlIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGRpcmVjdGx5XG4gKiAgIHJlbmRlcmVyLFxuICogICAvLyB0aGlzIHdpbGwgcmVzdG9yZSB0aGUgZnVsbCBIRFIgcmFuZ2VcbiAqICAgbWF4RGlzcGxheUJvb3N0OiBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCksXG4gKiAgIC4uLm1ldGFkYXRhXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqIEBwYXJhbSBwYXJhbXNcbiAqIEByZXR1cm5zXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFdlYkdMUmVuZGVyZXIgZmFpbHMgdG8gcmVuZGVyIHRoZSBnYWluIG1hcFxuICovXG5jb25zdCBkZWNvZGUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBzZHIsIGdhaW5NYXAsIHJlbmRlcmVyIH0gPSBwYXJhbXM7XG4gICAgaWYgKHNkci5jb2xvclNwYWNlICE9PSBTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1NEUiBDb2xvcnNwYWNlIG5lZWRzIHRvIGJlICpTUkdCQ29sb3JTcGFjZSosIHNldHRpbmcgaXQgYXV0b21hdGljYWxseScpO1xuICAgICAgICBzZHIuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuICAgIH1cbiAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGlmIChnYWluTWFwLmNvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignR2Fpbm1hcCBDb2xvcnNwYWNlIG5lZWRzIHRvIGJlICpMaW5lYXJTUkdCQ29sb3JTcGFjZSosIHNldHRpbmcgaXQgYXV0b21hdGljYWxseScpO1xuICAgICAgICBnYWluTWFwLmNvbG9yU3BhY2UgPSBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICB9XG4gICAgZ2Fpbk1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCh7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgc2RyLFxuICAgICAgICBnYWluTWFwXG4gICAgfSk7XG4gICAgY29uc3QgcXVhZFJlbmRlcmVyID0gbmV3IFF1YWRSZW5kZXJlcih7XG4gICAgICAgIC8vIFRPRE86IHRocmVlIHR5cGVzIGFyZSBnZW5lcmljLCBlc2xpbnQgY29tcGxhaW5zIGhlcmUsIHNlZSBob3cgd2UgY2FuIHNvbHZlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICB3aWR0aDogc2RyLmltYWdlLndpZHRoLFxuICAgICAgICAvLyBUT0RPOiB0aHJlZSB0eXBlcyBhcmUgZ2VuZXJpYywgZXNsaW50IGNvbXBsYWlucyBoZXJlLCBzZWUgaG93IHdlIGNhbiBzb2x2ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgaGVpZ2h0OiBzZHIuaW1hZ2UuaGVpZ2h0LFxuICAgICAgICB0eXBlOiBIYWxmRmxvYXRUeXBlLFxuICAgICAgICBjb2xvclNwYWNlOiBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgIHJlbmRlcmVyLFxuICAgICAgICByZW5kZXJUYXJnZXRPcHRpb25zOiBwYXJhbXMucmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG59O1xuXG5jbGFzcyBHYWluTWFwTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY2xhc3MgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jb25zdCBnZXRYTUxWYWx1ZSA9ICh4bWwsIHRhZywgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgLy8gQ2hlY2sgZm9yIGF0dHJpYnV0ZSBmb3JtYXQgZmlyc3Q6IHRhZz1cInZhbHVlXCJcbiAgICBjb25zdCBhdHRyaWJ1dGVNYXRjaCA9IG5ldyBSZWdFeHAoYCR7dGFnfT1cIihbXlwiXSopXCJgLCAnaScpLmV4ZWMoeG1sKTtcbiAgICBpZiAoYXR0cmlidXRlTWF0Y2gpXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVNYXRjaFsxXTtcbiAgICAvLyBDaGVjayBmb3IgdGFnIGZvcm1hdDogPHRhZz52YWx1ZTwvdGFnPiBvciA8dGFnPjxyZGY6bGk+dmFsdWU8L3JkZjpsaT4uLi48L3RhZz5cbiAgICBjb25zdCB0YWdNYXRjaCA9IG5ldyBSZWdFeHAoYDwke3RhZ31bXj5dKj4oW1xcXFxzXFxcXFNdKj8pPC8ke3RhZ30+YCwgJ2knKS5leGVjKHhtbCk7XG4gICAgaWYgKHRhZ01hdGNoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNvbnRhaW5zIHJkZjpsaSBlbGVtZW50c1xuICAgICAgICBjb25zdCBsaVZhbHVlcyA9IHRhZ01hdGNoWzFdLm1hdGNoKC88cmRmOmxpPihbXjxdKik8XFwvcmRmOmxpPi9nKTtcbiAgICAgICAgaWYgKGxpVmFsdWVzICYmIGxpVmFsdWVzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgcmV0dXJuIGxpVmFsdWVzLm1hcCh2ID0+IHYucmVwbGFjZSgvPFxcLz9yZGY6bGk+L2csICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ01hdGNoWzFdLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCAke3RhZ30gaW4gZ2Fpbm1hcCBtZXRhZGF0YWApO1xufTtcbmNvbnN0IGV4dHJhY3RYTVAgPSAoaW5wdXQpID0+IHtcbiAgICBsZXQgc3RyO1xuICAgIC8vIHN1cHBvcnQgbm9kZSB0ZXN0IGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHN0ciA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpbnB1dCk7XG4gICAgZWxzZVxuICAgICAgICBzdHIgPSBpbnB1dC50b1N0cmluZygpO1xuICAgIGxldCBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJyk7XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBlbmQgPSBzdHIuaW5kZXhPZigneDp4bXBtZXRhPicsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgeG1wQmxvY2sgPSBzdHIuc2xpY2Uoc3RhcnQsIGVuZCArIDEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNaW4gPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhaW5NYXBNaW4nLCAnMCcpO1xuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcE1heCA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206R2Fpbk1hcE1heCcpO1xuICAgICAgICAgICAgY29uc3QgZ2FtbWEgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhbW1hJywgJzEnKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFNEUiA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206T2Zmc2V0U0RSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIRFIgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOk9mZnNldEhEUicsICcwLjAxNTYyNScpO1xuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGFsd2F5cyBhdHRyaWJ1dGVzLCBzbyB3ZSBjYW4gdXNlIGEgc2ltcGxlciByZWdleFxuICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNaW5NYXRjaCA9IC9oZHJnbTpIRFJDYXBhY2l0eU1pbj1cIihbXlwiXSopXCIvLmV4ZWMoeG1wQmxvY2spO1xuICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNaW4gPSBoZHJDYXBhY2l0eU1pbk1hdGNoID8gaGRyQ2FwYWNpdHlNaW5NYXRjaFsxXSA6ICcwJztcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWF4TWF0Y2ggPSAvaGRyZ206SERSQ2FwYWNpdHlNYXg9XCIoW15cIl0qKVwiLy5leGVjKHhtcEJsb2NrKTtcbiAgICAgICAgICAgIGlmICghaGRyQ2FwYWNpdHlNYXhNYXRjaClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgZ2Fpbm1hcCBtZXRhZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNYXggPSBoZHJDYXBhY2l0eU1heE1hdGNoWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBnYWluTWFwTWluOiBBcnJheS5pc0FycmF5KGdhaW5NYXBNaW4pID8gZ2Fpbk1hcE1pbi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhaW5NYXBNaW4pLCBwYXJzZUZsb2F0KGdhaW5NYXBNaW4pLCBwYXJzZUZsb2F0KGdhaW5NYXBNaW4pXSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBBcnJheS5pc0FycmF5KGdhaW5NYXBNYXgpID8gZ2Fpbk1hcE1heC5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpXSxcbiAgICAgICAgICAgICAgICBnYW1tYTogQXJyYXkuaXNBcnJheShnYW1tYSkgPyBnYW1tYS5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhbW1hKSwgcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IEFycmF5LmlzQXJyYXkob2Zmc2V0U0RSKSA/IG9mZnNldFNEUi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KG9mZnNldFNEUiksIHBhcnNlRmxvYXQob2Zmc2V0U0RSKSwgcGFyc2VGbG9hdChvZmZzZXRTRFIpXSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IEFycmF5LmlzQXJyYXkob2Zmc2V0SERSKSA/IG9mZnNldEhEUi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KG9mZnNldEhEUiksIHBhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpXSxcbiAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1pbiksXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IHBhcnNlRmxvYXQoaGRyQ2FwYWNpdHlNYXgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBDb250aW51ZSBzZWFyY2hpbmcgZm9yIGFub3RoZXIgeG1wbWV0YSBibG9jayBpZiB0aGlzIG9uZSBmYWlsc1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gc3RyLmluZGV4T2YoJzx4OnhtcG1ldGEnLCBlbmQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTVBGIEV4dHJhY3RvciAoTXVsdGkgUGljdHVyZSBGb3JtYXQgRXh0cmFjdG9yKVxuICogQnkgSGVucmlrIFMgTmlsc3NvbiAyMDE5XG4gKlxuICogRXh0cmFjdHMgaW1hZ2VzIHN0b3JlZCBpbiBpbWFnZXMgYmFzZWQgb24gdGhlIE1QRiBmb3JtYXQgKGZvdW5kIGhlcmU6IGh0dHBzOi8vd3d3LmNpcGEuanAvZS9zdGQvc3RkLXNlYy5odG1sXG4gKiB1bmRlciBcIkNJUEEgREMtMDA3LVRyYW5zbGF0aW9uLTIwMjEgTXVsdGktUGljdHVyZSBGb3JtYXRcIlxuICpcbiAqIE92ZXJseSBjb21tZW50ZWQsIGFuZCB3aXRob3V0IGludGVudGlvbiBvZiBiZWluZyBjb21wbGV0ZSBvciBwcm9kdWN0aW9uIHJlYWR5LlxuICogQ3JlYXRlZCB0byBleHRyYWN0IGRlcHRoIG1hcHMgZnJvbSBpUGhvbmUgaW1hZ2VzLCBhbmQgdG8gbGVhcm4gYWJvdXQgaW1hZ2UgbWV0YWRhdGEuXG4gKiBLdWRvcyB0bzogUGhpbCBIYXJ2ZXkgKGV4aWZ0b29sKSwgSmF1bWUgU2FuY2hleiAoYW5kcm9pZC1sZW5zLWJsdXItZGVwdGgtZXh0cmFjdG9yKVxuICovXG5jbGFzcyBNUEZFeHRyYWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgZGVidWc6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWJ1ZyA6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFjdEZJSTogb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhY3RGSUkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdEZJSSA6IHRydWUsXG4gICAgICAgICAgICBleHRyYWN0Tm9uRklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdE5vbkZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0Tm9uRklJIDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleHRyYWN0KGltYWdlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnID0gdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoaW1hZ2VBcnJheUJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgLy8gSWYgeW91J3JlIGV4ZWN1dGluZyB0aGlzIGxpbmUgb24gYSBiaWcgZW5kaWFuIG1hY2hpbmUsIGl0J2xsIGJlIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gYmlnRW5kIGZ1cnRoZXIgZG93biB0aG91Z2gsIHJlZmVycyB0byB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaW1hZ2UgaXRzZWxmLlxuICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IGEgdmFsaWQganBlZycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgICAgICBsZXQgbG9vcHMgPSAwO1xuICAgICAgICAgICAgbGV0IG1hcmtlcjsgLy8gQVBQIyBtYXJrZXJcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytsb29wcyA+IDI1MCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGb3VuZCBubyBtYXJrZXIgYWZ0ZXIgJHtsb29wc30gbG9vcHMg8J+YtWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBOb3QgYSB2YWxpZCBtYXJrZXIgYXQgb2Zmc2V0IDB4JHtvZmZzZXQudG9TdHJpbmcoMTYpfSwgZm91bmQ6IDB4JHtkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpLnRvU3RyaW5nKDE2KX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFya2VyOiAke21hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gMHhlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgQVBQMiBtYXJrZXIgKDB4ZmZlMiknKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya3MgZm9yIGlQaG9uZSA4IFBsdXMsIFgsIGFuZCBYU01heC4gT3IgYW55IHBob3RvcyBvZiBNUEYgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBHcmVhdCB3YXkgdG8gdmlzdWFsaXplIGltYWdlIGluZm9ybWF0aW9uIGluIGh0bWwgaXMgdXNpbmcgRXhpZnRvb2wuIEUuZy46XG4gICAgICAgICAgICAgICAgICAgIC8vIC4vZXhpZnRvb2wuZXhlIC1odG1sZHVtcCAtd2FudFRyYWlsZXIgcGhvdG8uanBnID4gcGhvdG8uaHRtbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXRQdCA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqICBTdHJ1Y3R1cmUgb2YgdGhlIE1QIEZvcm1hdCBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqICBPZmZzZXQgQWRkci4gIHwgQ29kZSAoSGV4KSAgfCBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAwICAgICAgICAgICAgIGZmICAgICAgICAgICAgTWFya2VyIFByZWZpeCAgICAgIDwtLSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICogICswMSAgICAgICAgICAgICBlMiAgICAgICAgICAgIEFQUDJcbiAgICAgICAgICAgICAgICAgICAgICogICswMiAgICAgICAgICAgICAjbiAgICAgICAgICAgIEFQUDIgRmllbGQgTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAqICArMDMgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA0ICAgICAgICAgICAgIDRkICAgICAgICAgICAgJ00nICAgICAgICAgICAgICAgIDwtLSBmb3JtYXRQdFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA1ICAgICAgICAgICAgIDUwICAgICAgICAgICAgJ1AnXG4gICAgICAgICAgICAgICAgICAgICAqICArMDYgICAgICAgICAgICAgNDYgICAgICAgICAgICAnRidcbiAgICAgICAgICAgICAgICAgICAgICogICswNyAgICAgICAgICAgICAwMCAgICAgICAgICAgIE5VTExcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gdGlmZk9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMihmb3JtYXRQdCkgPT09IDB4NGQ1MDQ2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIE1QRiB0YWcsIHNvIHdlIHN0YXJ0IGRpZyBvdXQgc3ViIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlmZk9mZnNldCA9IGZvcm1hdFB0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaWdFbmQ7IC8vIEVuZGlhbm5lc3MgZnJvbSBUSUZGIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgVElGRiB2YWxpZGl0eSBhbmQgZW5kaWFubmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHg0OTQ5IGFuZCAweDRENEQgKCdJSScgYW5kICdNTScpIG1hcmtzIExpdHRsZSBFbmRpYW4gYW5kIEJpZyBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NDk0OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDRkNGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdmFsaWQgZW5kaWFubmVzcyBtYXJrZXIgZm91bmQgaW4gVElGRiBoZWFkZXInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChubyAweDAwMkEgbWFya2VyKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzMiBiaXQgbnVtYmVyIHN0YXRpbmcgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgOCBCeXRlIE1QIEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gTVAgSW5kZXggSUZEIExlYXN0IHBvc3NpYmxlIHZhbHVlIGlzIHRodXMgOCAobWVhbnMgMCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCAweDAwMDAwMDA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IHZhbGlkIFRJRkYgZGF0YSEgKEZpcnN0IG9mZnNldCBsZXNzIHRoYW4gOCknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBhaGVhZCB0byBNUCBJbmRleCBJRkRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB3ZSdyZSBhdCB0aGUgZmlyc3QgSUZELCBzbyBmaXJzdElGRE9mZnNldCBwb2ludHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1QIEluZGV4IElGRCBhbmQgbm90IE1QIEF0dHJpYnV0ZXMgSUZELiAoSWYgd2UgdHJ5IGV4dHJhY3QgZnJvbSBhIHN1YiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZhaWwgc2lsZW50bHkgaGVyZSBkdWUgdG8gdGhpcyBhc3N1bXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgKDIgQnl0ZSkgfCBNUCBJbmRleCBGaWVsZHMgYS5rLmEuIE1QIEVudHJpZXMgKGNvdW50ICogMTIgQnl0ZSkgfCBPZmZzZXQgb2YgTmV4dCBJRkQgKDQgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpclN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0OyAvLyBTdGFydCBvZiBJRkQgKEltYWdlIEZpbGUgRGlyZWN0b3J5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkYXRhVmlldy5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpOyAvLyBDb3VudCBvZiBNUEVudHJpZXMgKDIgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgaW5mbyBmcm9tIE1QRW50cmllcyAoc3RhcnRpbmcgYWZ0ZXIgQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzU3RhcnQgPSBkaXJTdGFydCArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnVtYmVyT2ZJbWFnZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVudHJpZXNTdGFydDsgaSA8IGVudHJpZXNTdGFydCArIDEyICogY291bnQ7IGkgKz0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGVudHJ5IGlzIDEyIEJ5dGVzIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBNUCBJbmRleCBJRkQgdGFncywgaGVyZSB3ZSBvbmx5IHRha2UgdGFnIDB4YjAwMSA9IE51bWJlciBvZiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KGksICFiaWdFbmQpID09PSAweGIwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIGluIExhc3QgNCBieXRlcyBvZiBpdHMgMTIgQnl0ZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXMgPSBkYXRhVmlldy5nZXRVaW50MzIoaSArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJRkRPZmZzZXRMZW4gPSA0OyAvLyA0IEJ5dGUgb2Zmc2V0IGZpZWxkIHRoYXQgYXBwZWFycyBhZnRlciBNUCBJbmRleCBJRkQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTVBJbWFnZUxpc3RWYWxQdCA9IGRpclN0YXJ0ICsgMiArIGNvdW50ICogMTIgKyBuZXh0SUZET2Zmc2V0TGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gTVBJbWFnZUxpc3RWYWxQdDsgaSA8IE1QSW1hZ2VMaXN0VmFsUHQgKyBudW1iZXJPZkltYWdlcyAqIDE2OyBpICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1QVHlwZTogZGF0YVZpZXcuZ2V0VWludDMyKGksICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDQsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9mZnNldCBpcyBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdGhlIGFkZHJlc3Mgb2YgdGhlIE1QIEVuZGlhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBpbiB0aGUgTVAgSGVhZGVyLCB1bmxlc3MgdGhlIGltYWdlIGlzIGEgRmlyc3QgSW5kaXZpZHVhbCBJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB0aGUgdmFsdWUgb2YgdGhlIG9mZnNldCBzaGFsbCBiZSBOVUxMICgweDAwMDAwMDAwKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kYW50SW1hZ2VzOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDEyLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZJSTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UuZGF0YU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhT2Zmc2V0IGlzIDB4MDAwMDAwMDAgZm9yIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IHRpZmZPZmZzZXQgKyBpbWFnZS5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbmQgPSBpbWFnZS5zdGFydCArIGltYWdlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYWN0Tm9uRklJICYmIGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJCbG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5pc0ZJSSAmJiAhdGhpcy5vcHRpb25zLmV4dHJhY3RGSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIEZJSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGJ1ZmZlckJsb2Iuc2xpY2UoaW1hZ2Uuc3RhcnQsIGltYWdlLmVuZCArIDEsICdpbWFnZS9qcGVnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VCbG9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcuc3JjID0gaW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1ncy5wdXNoKGltYWdlQmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBYTVAgTWV0YWRhdGEgYW5kIHRoZSBnYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICogZnJvbSBhIHNpbmdsZSBKUEVHIGZpbGUuXG4gKlxuICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICogQHBhcmFtIGpwZWdGaWxlIGFuIGBVaW50OEFycmF5YCBjb250YWluaW5nIGFuZCBlbmNvZGVkIEpQRUcgZmlsZVxuICogQHJldHVybnMgYW4gc2RyIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcsIGEgZ2Fpbk1hcCBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHIGFuZCB0aGUgWE1QIHBhcnNlZCBYTVAgbWV0YWRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgWE1QIE1ldGFkYXRhIGlzIG5vdCBmb3VuZFxuICogQHRocm93cyBFcnJvciBpZiBHYWluIG1hcCBpbWFnZSBpcyBub3QgZm91bmRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnXG4gKiBpbXBvcnQgeyBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKlxuICogY29uc3QganBlZ0ZpbGUgPSBhd2FpdCBuZXcgRmlsZUxvYWRlcigpXG4gKiAgLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKVxuICogIC5sb2FkQXN5bmMoJ2ltYWdlLmpwZycpXG4gKlxuICogY29uc3QgeyBzZHIsIGdhaW5NYXAsIG1ldGFkYXRhIH0gPSBleHRyYWN0R2Fpbm1hcEZyb21KUEVHKGpwZWdGaWxlKVxuICovXG5jb25zdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHID0gYXN5bmMgKGpwZWdGaWxlKSA9PiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYWN0WE1QKGpwZWdGaWxlKTtcbiAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yKCdHYWluIG1hcCBYTVAgbWV0YWRhdGEgbm90IGZvdW5kJyk7XG4gICAgY29uc3QgbXBmRXh0cmFjdG9yID0gbmV3IE1QRkV4dHJhY3Rvcih7IGV4dHJhY3RGSUk6IHRydWUsIGV4dHJhY3ROb25GSUk6IHRydWUgfSk7XG4gICAgY29uc3QgaW1hZ2VzID0gYXdhaXQgbXBmRXh0cmFjdG9yLmV4dHJhY3QoanBlZ0ZpbGUpO1xuICAgIGlmIChpbWFnZXMubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgR2Fpbk1hcE5vdEZvdW5kRXJyb3IoJ0dhaW4gbWFwIHJlY292ZXJ5IGltYWdlIG5vdCBmb3VuZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNkcjogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzBdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICBnYWluTWFwOiBuZXcgVWludDhBcnJheShhd2FpdCBpbWFnZXNbMV0uYXJyYXlCdWZmZXIoKSksXG4gICAgICAgIG1ldGFkYXRhXG4gICAgfTtcbn07XG5cbi8qKlxuICogcHJpdmF0ZSBmdW5jdGlvbiwgYXN5bmMgZ2V0IGltYWdlIGZyb20gYmxvYlxuICpcbiAqIEBwYXJhbSBibG9iXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBnZXRIVE1MSW1hZ2VGcm9tQmxvYiA9IChibG9iKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoaW1nKTsgfTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4geyByZWplY3QoZSk7IH07XG4gICAgICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH0pO1xufTtcblxuY2xhc3MgTG9hZGVyQmFzZSBleHRlbmRzIExvYWRlciB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gbWFuYWdlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBtYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgICAgICBpZiAocmVuZGVyZXIpXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHJlbmRlcmVyIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgZ2FpbiBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW5kZXJlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc2V0UmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHJlbmRlclRhcmdldCBvcHRpb25zIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgZ2FpbiBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzZXRSZW5kZXJUYXJnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgcHJlcGFyZVF1YWRSZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlcilcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogQW4gZXhpc3RpbmcgV2ViR0wgUmVuZGVyZXIgd2FzIG5vdCBwYXNzZWQgdG8gdGhpcyBMb2FkZXIgY29uc3RydWN0b3Igb3IgaW4gc2V0UmVuZGVyZXIsIHRoZSByZXN1bHQgb2YgdGhpcyBMb2FkZXIgd2lsbCBuZWVkIHRvIGJlIGNvbnZlcnRlZCB0byBhIERhdGEgVGV4dHVyZSB3aXRoIHRvRGF0YVRleHR1cmUoKSBiZWZvcmUgeW91IGNhbiB1c2UgaXQgaW4geW91ciByZW5kZXJlci4nKTtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IHZhbHVlc1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHtcbiAgICAgICAgICAgIGdhaW5NYXBNYXg6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgIGdhbW1hOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBvZmZzZXRIZHI6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIG9mZnNldFNkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IDEsXG4gICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogMCxcbiAgICAgICAgICAgIG1heERpc3BsYXlCb29zdDogMSxcbiAgICAgICAgICAgIGdhaW5NYXA6IG5ldyBUZXh0dXJlKCksXG4gICAgICAgICAgICBzZHI6IG5ldyBUZXh0dXJlKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHdpZHRoOiAxNixcbiAgICAgICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgICAgICB0eXBlOiBIYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgY29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlcixcbiAgICAgICAgICAgIHJlbmRlclRhcmdldE9wdGlvbnM6IHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gcXVhZFJlbmRlcmVyXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKiBAcGFyYW0gc2RyQnVmZmVyXG4gICAqIEBwYXJhbSBnYWluTWFwQnVmZmVyXG4gICAqL1xuICAgIGFzeW5jIHJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBvcHRpb25hbCwgd2lsbCByZW5kZXIgYSBibGFjayBnYWluLW1hcCBpZiBub3QgcHJlc2VudFxuICAgICAgICBjb25zdCBnYWluTWFwQmxvYiA9IGdhaW5NYXBCdWZmZXIgPyBuZXcgQmxvYihbZ2Fpbk1hcEJ1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzZHJCbG9iID0gbmV3IEJsb2IoW3NkckJ1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pO1xuICAgICAgICBsZXQgc2RySW1hZ2U7XG4gICAgICAgIGxldCBnYWluTWFwSW1hZ2U7XG4gICAgICAgIGxldCBuZWVkc0ZsaXAgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBnYWluTWFwQmxvYiA/IGdldEhUTUxJbWFnZUZyb21CbG9iKGdhaW5NYXBCbG9iKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGdldEhUTUxJbWFnZUZyb21CbG9iKHNkckJsb2IpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGdhaW5NYXBJbWFnZSA9IHJlc1swXTtcbiAgICAgICAgICAgIHNkckltYWdlID0gcmVzWzFdO1xuICAgICAgICAgICAgbmVlZHNGbGlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBnYWluTWFwQmxvYiA/IGNyZWF0ZUltYWdlQml0bWFwKGdhaW5NYXBCbG9iLCB7IGltYWdlT3JpZW50YXRpb246ICdmbGlwWScgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChzZHJCbG9iLCB7IGltYWdlT3JpZW50YXRpb246ICdmbGlwWScgfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgZ2Fpbk1hcEltYWdlID0gcmVzWzBdO1xuICAgICAgICAgICAgc2RySW1hZ2UgPSByZXNbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2Fpbk1hcCA9IG5ldyBUZXh0dXJlKGdhaW5NYXBJbWFnZSB8fCBuZXcgSW1hZ2VEYXRhKDIsIDIpLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlLCAxLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIGdhaW5NYXAuZmxpcFkgPSBuZWVkc0ZsaXA7XG4gICAgICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBzZHIgPSBuZXcgVGV4dHVyZShzZHJJbWFnZSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgMSwgU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBzZHIuZmxpcFkgPSBuZWVkc0ZsaXA7XG4gICAgICAgIHNkci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHF1YWRSZW5kZXJlci53aWR0aCA9IHNkckltYWdlLndpZHRoO1xuICAgICAgICBxdWFkUmVuZGVyZXIuaGVpZ2h0ID0gc2RySW1hZ2UuaGVpZ2h0O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcCA9IGdhaW5NYXA7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5zZHIgPSBzZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwTWluID0gbWV0YWRhdGEuZ2Fpbk1hcE1pbjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNYXggPSBtZXRhZGF0YS5nYWluTWFwTWF4O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwub2Zmc2V0SGRyID0gbWV0YWRhdGEub2Zmc2V0SGRyO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwub2Zmc2V0U2RyID0gbWV0YWRhdGEub2Zmc2V0U2RyO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2FtbWEgPSBtZXRhZGF0YS5nYW1tYTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWluID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW47XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5oZHJDYXBhY2l0eU1heCA9IG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4O1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwubWF4RGlzcGxheUJvb3N0ID0gTWF0aC5wb3coMiwgbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXgpO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBxdWFkUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgVGhyZWUuanMgTG9hZGVyIGZvciB0aGUgZ2FpbiBtYXAgZm9ybWF0LlxuICpcbiAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gKiBAZ3JvdXAgTG9hZGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBHYWluTWFwTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAqICAgTGluZWFyRmlsdGVyLFxuICogICBNZXNoLFxuICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gKiAgIFBsYW5lR2VvbWV0cnksXG4gKiAgIFNjZW5lLFxuICogICBXZWJHTFJlbmRlcmVyXG4gKiB9IGZyb20gJ3RocmVlJ1xuICpcbiAqIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKVxuICpcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBHYWluTWFwTG9hZGVyKHJlbmRlcmVyKVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoWydzZHIuanBlZycsICdnYWlubWFwLmpwZWcnLCAnbWV0YWRhdGEuanNvbiddKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIFN0YXJ0aW5nIGZyb20gdGhyZWUuanMgcjE1OVxuICogLy8gYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgY2FuXG4gKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAqIC8vXG4gKiAvLyBpdCB3YXMgcHJldmlvdXNseSBuZWVkZWQgdG8gY29udmVydCBpdFxuICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICogc2NlbmUuYmFja2dyb3VuZCA9IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZVxuICogc2NlbmUuYmFja2dyb3VuZC5tYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmdcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKi9cbmNsYXNzIEdhaW5NYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlIHtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGdhaW5tYXAgdXNpbmcgc2VwYXJhdGUgZGF0YVxuICAgICAqICogc2RyIGltYWdlXG4gICAgICogKiBnYWluIG1hcCBpbWFnZVxuICAgICAqICogbWV0YWRhdGEganNvblxuICAgICAqXG4gICAgICogdXNlZnVsIGZvciB3ZWJwIGdhaW4gbWFwc1xuICAgICAqXG4gICAgICogQHBhcmFtIHVybHMgQW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW3Nkci5qcGcsIGdhaW5tYXAuanBnLCBtZXRhZGF0YS5qc29uXVxuICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBQcm9ncmVzcyBjYWxsYmFjaywgd2lsbCByZWNlaXZlIGEge0BsaW5rIFByb2dyZXNzRXZlbnR9XG4gICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGxvYWQoW3NkclVybCwgZ2Fpbk1hcFVybCwgbWV0YWRhdGFVcmxdLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgIGxldCBzZHI7XG4gICAgICAgIGxldCBnYWluTWFwO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IGxvYWRDaGVjayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZHIgJiYgZ2Fpbk1hcCAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHIsIGdhaW5NYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQocXVhZFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChzZHJVcmwpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNkckxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgc2RyVG90YWwgPSAwO1xuICAgICAgICBsZXQgc2RyTG9hZGVkID0gMDtcbiAgICAgICAgbGV0IGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGdhaW5NYXBUb3RhbCA9IDA7XG4gICAgICAgIGxldCBnYWluTWFwTG9hZGVkID0gMDtcbiAgICAgICAgbGV0IG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBtZXRhZGF0YVRvdGFsID0gMDtcbiAgICAgICAgbGV0IG1ldGFkYXRhTG9hZGVkID0gMDtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBzZHJUb3RhbCArIGdhaW5NYXBUb3RhbCArIG1ldGFkYXRhVG90YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gc2RyTG9hZGVkICsgZ2Fpbk1hcExvYWRlZCArIG1ldGFkYXRhTG9hZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aENvbXB1dGFibGUgPSBzZHJMZW5ndGhDb21wdXRhYmxlICYmIGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlICYmIG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzKG5ldyBQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIHsgbGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoc2RyVXJsKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChnYWluTWFwVXJsKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChtZXRhZGF0YVVybCk7XG4gICAgICAgIGNvbnN0IHNkckxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBzZHJMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgc2RyTG9hZGVyLmxvYWQoc2RyVXJsLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNkciBidWZmZXInKTtcbiAgICAgICAgICAgIHNkciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgc2RyTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIHNkckxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgc2RyVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2Fpbk1hcExvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIubG9hZChnYWluTWFwVXJsLCBhc3luYyAoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdhaW5tYXAgYnVmZmVyJyk7XG4gICAgICAgICAgICBnYWluTWFwID0gYnVmZmVyO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIGdhaW5NYXBUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgLy8gbWV0YWRhdGFMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdqc29uJylcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLmxvYWQobWV0YWRhdGFVcmwsIGFzeW5jIChqc29uKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpzb24gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRhZGF0YSBzdHJpbmcnKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjaGVjayBvbiBKU09OIGZpbGUgYW5kIHJlbW92ZSB0aGlzIGVzbGludCBkaXNhYmxlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBtZXRhZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIG1ldGFkYXRhTGVuZ3RoQ29tcHV0YWJsZSA9IGUubGVuZ3RoQ29tcHV0YWJsZTtcbiAgICAgICAgICAgIG1ldGFkYXRhTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBtZXRhZGF0YVRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQSBUaHJlZS5qcyBMb2FkZXIgZm9yIGEgSlBFRyB3aXRoIGVtYmVkZGVkIGdhaW5tYXAgbWV0YWRhdGEuXG4gKlxuICogQGNhdGVnb3J5IExvYWRlcnNcbiAqIEBncm91cCBMb2FkZXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEhEUkpQR0xvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG4gKiAgIExpbmVhckZpbHRlcixcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICpcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gKiApXG4gKiBzY2VuZS5hZGQobWVzaClcbiAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gKlxuICogLy8gU3RhcnRpbmcgZnJvbSB0aHJlZS5qcyByMTU5XG4gKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAqIC8vIGFsc28gYmUgdXNlZCBhcyBFcXVpcmVjdGFuZ3VsYXIgc2NlbmUgYmFja2dyb3VuZFxuICogLy9cbiAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gKiAvLyB0byBhIERhdGFUZXh0dXJlIHdpdGggYHJlc3VsdC50b0RhdGFUZXh0dXJlKClgXG4gKiBzY2VuZS5iYWNrZ3JvdW5kID0gcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlXG4gKiBzY2VuZS5iYWNrZ3JvdW5kLm1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZ1xuICpcbiAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICogcmVzdWx0LmRpc3Bvc2UoKVxuICpcbiAqL1xuY2xhc3MgSERSSlBHTG9hZGVyIGV4dGVuZHMgTG9hZGVyQmFzZSB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBKUEVHIGNvbnRhaW5pbmcgZ2FpbiBtYXAgbWV0YWRhdGFcbiAgICAgKiBSZW5kZXJzIGEgbm9ybWFsIFNEUiBpbWFnZSBpZiBnYWlubWFwIGRhdGEgaXMgbm90IGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIEFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtzZHIuanBnLCBnYWlubWFwLmpwZywgbWV0YWRhdGEuanNvbl1cbiAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIHtAbGluayBQcm9ncmVzc0V2ZW50fVxuICAgICAqIEBwYXJhbSBvbkVycm9yIEVycm9yIGNhbGxiYWNrXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICAgICAgbG9hZGVyLmxvYWQodXJsLCBhc3luYyAoanBlZykgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqcGVnID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnVmZmVyLCByZWNlaXZlZCBbc3RyaW5nXSwgd2FzIGV4cGVjdGluZyBbQXJyYXlCdWZmZXJdJyk7XG4gICAgICAgICAgICBjb25zdCBqcGVnQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoanBlZyk7XG4gICAgICAgICAgICBsZXQgc2RySlBFRztcbiAgICAgICAgICAgIGxldCBnYWluTWFwSlBFRztcbiAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFjdGlvblJlc3VsdCA9IGF3YWl0IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcoanBlZ0J1ZmZlcik7XG4gICAgICAgICAgICAgICAgLy8gZ2FpbiBtYXAgaXMgc3VjY2Vzc2Z1bGx5IHJlY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICBzZHJKUEVHID0gZXh0cmFjdGlvblJlc3VsdC5zZHI7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LmdhaW5NYXA7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBleHRyYWN0aW9uUmVzdWx0Lm1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIFNEUiB2ZXJzaW9uIGlmIHRoaXMgaXMgbm90IGEgZ2Fpbm1hcFxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIHx8IGUgaW5zdGFuY2VvZiBHYWluTWFwTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWx1cmUgdG8gcmVjb25zdHJ1Y3QgYW4gSERSIGltYWdlIGZyb20gJHt1cmx9OiBHYWluIG1hcCBtZXRhZGF0YSBub3QgZm91bmQgaW4gdGhlIGZpbGUsIEhEUkpQR0xvYWRlciB3aWxsIHJlbmRlciB0aGUgU0RSIGpwZWdgKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWluOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnYW1tYTogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEhkcjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMCwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2RySlBFRyA9IGpwZWdCdWZmZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RySlBFRywgZ2Fpbk1hcEpQRUcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25Mb2FkKHF1YWRSZW5kZXJlcik7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgIH0sIG9uUHJvZ3Jlc3MsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwsIEdhaW5NYXBMb2FkZXIsIEhEUkpQR0xvYWRlciwgSERSSlBHTG9hZGVyIGFzIEpQRUdSTG9hZGVyLCBNUEZFeHRyYWN0b3IsIFF1YWRSZW5kZXJlciwgZGVjb2RlLCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHLCBleHRyYWN0WE1QIH07XG4iXSwibmFtZXMiOlsiUSIsIlF1YWRSZW5kZXJlciIsIlNoYWRlck1hdGVyaWFsIiwiVmVjdG9yMyIsIk5vQmxlbmRpbmciLCJTUkdCQ29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwiSGFsZkZsb2F0VHlwZSIsIkxvYWRlciIsIkxvYWRpbmdNYW5hZ2VyIiwiVGV4dHVyZSIsIlVWTWFwcGluZyIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsIkZpbGVMb2FkZXIiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsIkdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwiLCJjb25zdHJ1Y3RvciIsImdhbW1hIiwib2Zmc2V0SGRyIiwib2Zmc2V0U2RyIiwiZ2Fpbk1hcE1pbiIsImdhaW5NYXBNYXgiLCJtYXhEaXNwbGF5Qm9vc3QiLCJoZHJDYXBhY2l0eU1pbiIsImhkckNhcGFjaXR5TWF4Iiwic2RyIiwiZ2Fpbk1hcCIsIm5hbWUiLCJ1bmlmb3JtcyIsInZhbHVlIiwiZnJvbUFycmF5Iiwid2VpZ2h0RmFjdG9yIiwiTWF0aCIsImxvZzIiLCJibGVuZGluZyIsImRlcHRoVGVzdCIsImRlcHRoV3JpdGUiLCJfbWF4RGlzcGxheUJvb3N0IiwiX2hkckNhcGFjaXR5TWluIiwiX2hkckNhcGFjaXR5TWF4IiwibmVlZHNVcGRhdGUiLCJ1bmlmb3Jtc05lZWRVcGRhdGUiLCJ0b0FycmF5IiwiZyIsIngiLCJ5IiwieiIsImNhbGN1bGF0ZVdlaWdodCIsIm1heCIsIm1pbiIsInZhbCIsImRlY29kZSIsInBhcmFtcyIsInJlbmRlcmVyIiwiY29sb3JTcGFjZSIsImNvbnNvbGUiLCJ3YXJuIiwibWF0ZXJpYWwiLCJxdWFkUmVuZGVyZXIiLCJ3aWR0aCIsImltYWdlIiwiaGVpZ2h0IiwidHlwZSIsInJlbmRlclRhcmdldE9wdGlvbnMiLCJyZW5kZXIiLCJlIiwiZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIiLCJHYWluTWFwTm90Rm91bmRFcnJvciIsIkVycm9yIiwiWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yIiwiZ2V0WE1MVmFsdWUiLCJ4bWwiLCJ0YWciLCJkZWZhdWx0VmFsdWUiLCJhdHRyaWJ1dGVNYXRjaCIsIlJlZ0V4cCIsImV4ZWMiLCJ0YWdNYXRjaCIsImxpVmFsdWVzIiwibWF0Y2giLCJsZW5ndGgiLCJtYXAiLCJ2IiwicmVwbGFjZSIsInRyaW0iLCJ1bmRlZmluZWQiLCJleHRyYWN0WE1QIiwiaW5wdXQiLCJzdHIiLCJUZXh0RGVjb2RlciIsInRvU3RyaW5nIiwic3RhcnQiLCJpbmRleE9mIiwiZW5kIiwieG1wQmxvY2siLCJzbGljZSIsIm9mZnNldFNEUiIsIm9mZnNldEhEUiIsImhkckNhcGFjaXR5TWluTWF0Y2giLCJoZHJDYXBhY2l0eU1heE1hdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VGbG9hdCIsIk1QRkV4dHJhY3RvciIsIm9wdGlvbnMiLCJkZWJ1ZyIsImV4dHJhY3RGSUkiLCJleHRyYWN0Tm9uRklJIiwiZXh0cmFjdCIsImltYWdlQXJyYXlCdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJnZXRVaW50MTYiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwibG9vcHMiLCJtYXJrZXIiLCJnZXRVaW50OCIsImxvZyIsImZvcm1hdFB0IiwiZ2V0VWludDMyIiwidGlmZk9mZnNldCIsImJpZ0VuZCIsImZpcnN0SUZET2Zmc2V0IiwiZGlyU3RhcnQiLCJjb3VudCIsImVudHJpZXNTdGFydCIsIm51bWJlck9mSW1hZ2VzIiwiaSIsIm5leHRJRkRPZmZzZXRMZW4iLCJNUEltYWdlTGlzdFZhbFB0IiwiaW1hZ2VzIiwiTVBUeXBlIiwic2l6ZSIsImRhdGFPZmZzZXQiLCJkZXBlbmRhbnRJbWFnZXMiLCJpc0ZJSSIsInB1c2giLCJidWZmZXJCbG9iIiwiQmxvYiIsImltZ3MiLCJpbWFnZUJsb2IiLCJleHRyYWN0R2Fpbm1hcEZyb21KUEVHIiwianBlZ0ZpbGUiLCJtZXRhZGF0YSIsIm1wZkV4dHJhY3RvciIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImdldEhUTUxJbWFnZUZyb21CbG9iIiwiYmxvYiIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJMb2FkZXJCYXNlIiwibWFuYWdlciIsIl9yZW5kZXJlciIsIl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyIiwic2V0UmVuZGVyZXIiLCJzZXRSZW5kZXJUYXJnZXRPcHRpb25zIiwiX3JlbmRlclRhcmdldE9wdGlvbnMiLCJwcmVwYXJlUXVhZFJlbmRlcmVyIiwic2RyQnVmZmVyIiwiZ2Fpbk1hcEJ1ZmZlciIsImdhaW5NYXBCbG9iIiwic2RyQmxvYiIsInNkckltYWdlIiwiZ2Fpbk1hcEltYWdlIiwibmVlZHNGbGlwIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJyZXMiLCJhbGwiLCJpbWFnZU9yaWVudGF0aW9uIiwiSW1hZ2VEYXRhIiwiZmxpcFkiLCJwb3ciLCJHYWluTWFwTG9hZGVyIiwibG9hZCIsInNkclVybCIsImdhaW5NYXBVcmwiLCJtZXRhZGF0YVVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwibG9hZENoZWNrIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwic2RyTGVuZ3RoQ29tcHV0YWJsZSIsInNkclRvdGFsIiwic2RyTG9hZGVkIiwiZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUiLCJnYWluTWFwVG90YWwiLCJnYWluTWFwTG9hZGVkIiwibWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlIiwibWV0YWRhdGFUb3RhbCIsIm1ldGFkYXRhTG9hZGVkIiwicHJvZ3Jlc3NIYW5kbGVyIiwidG90YWwiLCJsb2FkZWQiLCJsZW5ndGhDb21wdXRhYmxlIiwiUHJvZ3Jlc3NFdmVudCIsIml0ZW1TdGFydCIsInNkckxvYWRlciIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0UGF0aCIsInBhdGgiLCJzZXRXaXRoQ3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJnYWluTWFwTG9hZGVyIiwibWV0YWRhdGFMb2FkZXIiLCJqc29uIiwiSlNPTiIsInBhcnNlIiwiSERSSlBHTG9hZGVyIiwidXJsIiwibG9hZGVyIiwianBlZyIsImpwZWdCdWZmZXIiLCJzZHJKUEVHIiwiZ2Fpbk1hcEpQRUciLCJleHRyYWN0aW9uUmVzdWx0IiwiSlBFR1JMb2FkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;