"""
AutoCrate Web API
FastAPI backend for AutoCrate web version
"""

from fastapi import FastAPI, HTTPException, Depends, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, StreamingResponse, HTMLResponse, RedirectResponse
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional, Dict, Any
import sys
import os
from pathlib import Path
import json
import io
import base64
from datetime import datetime
import uuid
from logs import router as logs_router

# Add parent directory to path for importing autocrate modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import core AutoCrate modules
try:
    from autocrate.front_panel_logic import calculate_front_panel_components
    from autocrate.back_panel_logic import calculate_back_panel_components
    from autocrate.left_panel_logic import calculate_left_panel_components
    from autocrate.right_panel_logic import calculate_right_panel_components
    from autocrate.top_panel_logic import calculate_top_panel_components
except ImportError as e:
    print(f"Warning: Could not import AutoCrate modules: {e}")
    # Mock functions for development
    def calculate_front_panel_components(*args, **kwargs):
        return {"cleats": [], "plywood": []}
    def calculate_back_panel_components(*args, **kwargs):
        return {"cleats": [], "plywood": []}
    def calculate_left_panel_components(*args, **kwargs):
        return {"cleats": [], "plywood": []}
    def calculate_right_panel_components(*args, **kwargs):
        return {"cleats": [], "plywood": []}
    def calculate_top_panel_components(*args, **kwargs):
        return {"cleats": [], "plywood": []}
    def generate_nx_expressions_content(*args, **kwargs):
        return "# NX Expressions File\n# Generated by AutoCrate Web"

# Initialize FastAPI app
app = FastAPI(
    title="AutoCrate API",
    description="Professional crate design and calculation API with ASTM compliance",
    version="1.0.0",
    docs_url="/api/docs",
    redoc_url="/api/redoc"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include logging router
app.include_router(logs_router, prefix="/api", tags=["logging"])

# Root endpoint - redirect to documentation
@app.get("/")
def root():
    """Root endpoint with API information"""
    return {
        "name": "AutoCrate V12 API",
        "version": "12.0.0",
        "description": "Professional crate design and calculation API with ASTM compliance",
        "documentation": "/docs",
        "redoc": "/redoc",
        "health": "/health",
        "endpoints": {
            "calculate": "/api/calculate",
            "export_nx": "/api/export/nx_expression",
            "export_bom": "/api/export/bom",
            "validate": "/api/validate"
        },
        "message": "Welcome to AutoCrate API! Visit /docs for interactive documentation."
    }

# API root endpoint
@app.get("/api")
def api_root():
    """API root endpoint with available routes"""
    return {
        "status": "online",
        "service": "AutoCrate V12 API",
        "version": "12.0.0",
        "endpoints": {
            "calculate": "/api/calculate",
            "export": {
                "nx_expression": "/api/export/nx_expression",
                "bom": "/api/export/bom",
                "report": "/api/export/report"
            },
            "validate": "/api/validate",
            "logs": "/api/logs"
        }
    }

# Health check endpoint
@app.get("/health")
def health_check():
    """Health check endpoint for Railway/monitoring"""
    return {"status": "healthy", "service": "autocrate-api", "version": "12.0.0"}

# ============= DATA MODELS =============

class MaterialSpec(BaseModel):
    """Material specifications"""
    panel_thickness: float = Field(0.75, ge=0.25, le=2.0, description="Panel thickness in inches")
    lumber_sizes: List[str] = Field(default=["1.5x3.5", "1.5x5.5"], description="Available lumber sizes")
    material_type: str = Field("plywood", pattern="^(plywood|osb)$", description="Panel material type")
    
class ProductSpec(BaseModel):
    """Product specifications for crate design"""
    length: float = Field(..., ge=12, le=130, description="Product length in inches")
    width: float = Field(..., ge=12, le=130, description="Product width in inches")
    height: float = Field(..., ge=12, le=130, description="Product height in inches")
    weight: float = Field(..., ge=1, le=20000, description="Product weight in pounds")
    
    @field_validator('length', 'width', 'height')
    @classmethod
    def validate_dimensions(cls, v: float) -> float:
        if v < 12:
            raise ValueError(f"Dimension must be at least 12 inches")
        if v > 130:
            raise ValueError(f"Dimension must not exceed 130 inches")
        return v

class CrateRequest(BaseModel):
    """Complete crate calculation request"""
    product: ProductSpec
    materials: MaterialSpec = MaterialSpec()
    clearance: float = Field(2.0, ge=0.5, le=6.0, description="Clearance in inches")
    include_top: bool = Field(True, description="Include top panel")
    include_3d_data: bool = Field(False, description="Include 3D geometry data")

class CalculationResponse(BaseModel):
    """Crate calculation response"""
    request_id: str
    timestamp: str
    product_specs: Dict[str, Any]
    panels: Dict[str, Any]
    materials_summary: Dict[str, Any]
    compliance: Dict[str, Any]
    export_available: List[str]

class BOMItem(BaseModel):
    """Bill of Materials item"""
    category: str
    description: str
    quantity: float
    unit: str
    unit_cost: Optional[float] = None
    total_cost: Optional[float] = None

class GeometryData(BaseModel):
    """3D geometry data for visualization"""
    panels: List[Dict[str, Any]]
    cleats: List[Dict[str, Any]]
    dimensions: Dict[str, float]
    materials: Dict[str, Any]

# ============= CALCULATION ENGINE =============

class CalculationEngine:
    """Core calculation engine wrapper"""
    
    @staticmethod
    def calculate_crate(request: CrateRequest) -> Dict[str, Any]:
        """Calculate complete crate design"""
        
        # Extract parameters
        product_length = request.product.length
        product_width = request.product.width
        product_height = request.product.height
        product_weight = request.product.weight
        panel_thickness = request.materials.panel_thickness
        clearance = request.clearance
        
        # Standard lumber sizes (will be made configurable later)
        cleat_thickness = 1.5
        cleat_width = 3.5
        
        # Calculate crate dimensions
        crate_length = product_length + 2 * clearance
        crate_width = product_width + 2 * clearance
        crate_height = product_height + clearance
        
        # Calculate panel dimensions
        front_width = crate_length + 2 * cleat_thickness
        front_height = crate_height + cleat_width
        
        side_width = crate_width
        side_height = crate_height + cleat_width
        
        top_length = product_length + 2 * clearance + 2 * panel_thickness
        top_width = product_width + 2 * clearance + 2 * panel_thickness
        
        # Calculate panels
        results = {
            "crate_dimensions": {
                "internal_length": crate_length,
                "internal_width": crate_width,
                "internal_height": crate_height,
                "external_length": front_width,
                "external_width": side_width + 2 * panel_thickness,
                "external_height": front_height
            },
            "panels": {}
        }
        
        # Front panel
        try:
            front_result = calculate_front_panel_components(
                front_width, front_height, panel_thickness,
                cleat_thickness, cleat_width, True
            )
            results["panels"]["front"] = {
                "width": front_width,
                "height": front_height,
                "components": front_result
            }
        except Exception as e:
            results["panels"]["front"] = {"error": str(e)}
        
        # Back panel  
        try:
            back_result = calculate_back_panel_components(
                front_width, front_height, panel_thickness,
                cleat_thickness, cleat_width, True
            )
            results["panels"]["back"] = {
                "width": front_width,
                "height": front_height,
                "components": back_result
            }
        except Exception as e:
            results["panels"]["back"] = {"error": str(e)}
        
        # Left panel
        try:
            left_result = calculate_left_panel_components(
                side_width, side_height, panel_thickness,
                cleat_thickness, cleat_width, True
            )
            results["panels"]["left"] = {
                "width": side_width,
                "height": side_height,
                "components": left_result
            }
        except Exception as e:
            results["panels"]["left"] = {"error": str(e)}
        
        # Right panel
        try:
            right_result = calculate_right_panel_components(
                side_width, side_height, panel_thickness,
                cleat_thickness, cleat_width, True
            )
            results["panels"]["right"] = {
                "width": side_width,
                "height": side_height,
                "components": right_result
            }
        except Exception as e:
            results["panels"]["right"] = {"error": str(e)}
        
        # Top panel (if requested)
        if request.include_top:
            try:
                top_result = calculate_top_panel_components(
                    top_length, top_width, panel_thickness,
                    cleat_thickness, cleat_width
                )
                results["panels"]["top"] = {
                    "length": top_length,
                    "width": top_width,
                    "components": top_result
                }
            except Exception as e:
                results["panels"]["top"] = {"error": str(e)}
        
        # Calculate materials summary
        results["materials_summary"] = CalculationEngine._calculate_materials_summary(results["panels"])
        
        # Add compliance information
        results["compliance"] = {
            "astm_d6251": True,
            "safety_factor": 1.5,
            "max_load": product_weight * 1.5,
            "standards_met": ["ASTM D6251-17", "ISPM 15"]
        }
        
        return results
    
    @staticmethod
    def _calculate_materials_summary(panels: Dict) -> Dict:
        """Calculate total materials needed"""
        total_plywood_area = 0
        total_lumber_length = 0
        num_panels = 0
        
        for panel_name, panel_data in panels.items():
            if "error" not in panel_data and "components" in panel_data:
                num_panels += 1
                # Add logic to sum up materials from components
                # This is simplified for now
                if panel_name in ["front", "back"]:
                    total_plywood_area += panel_data["width"] * panel_data["height"]
                elif panel_name in ["left", "right"]:
                    total_plywood_area += panel_data["width"] * panel_data["height"]
                elif panel_name == "top":
                    total_plywood_area += panel_data["length"] * panel_data["width"]
        
        # Convert to standard sheet count (4x8 = 32 sq ft = 4608 sq in)
        sheets_required = total_plywood_area / 4608
        
        return {
            "plywood_sheets": round(sheets_required + 0.5),  # Round up
            "total_area_sqft": round(total_plywood_area / 144, 2),
            "lumber_length_ft": round(total_lumber_length / 12, 2),
            "num_panels": num_panels,
            "estimated_weight_lbs": round(sheets_required * 50, 2)  # ~50 lbs per sheet
        }

# ============= API ENDPOINTS =============

@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "version": "1.0.0",
        "timestamp": datetime.utcnow().isoformat()
    }

@app.post("/api/calculate", response_model=CalculationResponse)
async def calculate_crate(request: CrateRequest):
    """Calculate crate design based on product specifications"""
    try:
        # Generate request ID
        request_id = str(uuid.uuid4())
        
        # Perform calculations
        engine = CalculationEngine()
        results = engine.calculate_crate(request)
        
        # Prepare response
        response = CalculationResponse(
            request_id=request_id,
            timestamp=datetime.utcnow().isoformat(),
            product_specs=request.product.dict(),
            panels=results["panels"],
            materials_summary=results["materials_summary"],
            compliance=results["compliance"],
            export_available=["nx_expression", "bom_excel", "bom_csv", "report_pdf", "3d_model"]
        )
        
        return response
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/api/validate")
async def validate_inputs(request: CrateRequest):
    """Validate crate specifications"""
    try:
        # Validation logic
        warnings = []
        errors = []
        
        # Check aspect ratios
        length_width_ratio = request.product.length / request.product.width
        if length_width_ratio > 3 or length_width_ratio < 0.33:
            warnings.append("Unusual aspect ratio may require special consideration")
        
        # Check weight distribution
        base_area = request.product.length * request.product.width
        weight_per_sqin = request.product.weight / base_area
        if weight_per_sqin > 10:
            warnings.append("High weight concentration - consider reinforced base")
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings,
            "recommendations": []
        }
        
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/api/export/nx_expression")
async def export_nx_expression(request: CrateRequest):
    """Generate and download NX expression file"""
    try:
        # Import the NX expression service
        from nx_expression_service import generate_full_nx_expression_content
        
        # Generate the full NX expression content using core logic
        content = generate_full_nx_expression_content(
            product_weight=request.product.weight,
            product_length=request.product.length,
            product_width=request.product.width,
            product_height=request.product.height,
            clearance=request.clearance,
            panel_thickness=request.materials.panel_thickness,
            include_top=request.include_top,
            lumber_sizes=request.materials.lumber_sizes
        )
        
        # Create timestamp for filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Enhanced filename with more parameters
        material_type = "PLY" if request.materials.panel_thickness >= 0.5 else "OSB"
        filename = (f"{timestamp}_Crate_"
                   f"{request.product.length:.0f}x{request.product.width:.0f}x{request.product.height:.0f}_"
                   f"W{request.product.weight:.0f}_"
                   f"5P_"  # 5 panels
                   f"{material_type}{request.materials.panel_thickness:.2f}_"
                   f"C{request.clearance:.1f}_"
                   f"ASTM.exp")
        
        return StreamingResponse(
            io.StringIO(content),
            media_type="text/plain",
            headers={
                "Content-Disposition": f"attachment; filename={filename}",
                "Access-Control-Expose-Headers": "Content-Disposition"
            }
        )
        
    except ImportError as e:
        # Fallback to simple generation if import fails
        print(f"Import error, using fallback: {e}")
        content = generate_nx_expression_content_fallback(request)
        
        # Create timestamp for filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        material_type = "PLY" if request.materials.panel_thickness >= 0.5 else "OSB"
        filename = (f"{timestamp}_Crate_"
                   f"{request.product.length:.0f}x{request.product.width:.0f}x{request.product.height:.0f}_"
                   f"W{request.product.weight:.0f}_"
                   f"5P_"
                   f"{material_type}{request.materials.panel_thickness:.2f}_"
                   f"C{request.clearance:.1f}_"
                   f"ASTM.exp")
        
        return StreamingResponse(
            io.StringIO(content),
            media_type="text/plain",
            headers={
                "Content-Disposition": f"attachment; filename={filename}",
                "Access-Control-Expose-Headers": "Content-Disposition"
            }
        )
    except Exception as e:
        print(f"Error in NX generation: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

def generate_nx_expression_content_fallback(request: CrateRequest) -> str:
    """Generate basic NX expression file content as fallback"""
    # First calculate to get results
    engine = CalculationEngine()
    results = engine.calculate_crate(request)
    lines = []
    
    # Header
    lines.append("# NX Expression File")
    lines.append(f"# Generated by AutoCrate V12 Web")
    lines.append(f"# Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("#" + "=" * 50)
    lines.append("")
    
    # Product parameters
    lines.append("# PRODUCT PARAMETERS")
    lines.append(f"Product_Length = {request.product.length}")
    lines.append(f"Product_Width = {request.product.width}")
    lines.append(f"Product_Height = {request.product.height}")
    lines.append(f"Product_Weight = {request.product.weight}")
    lines.append("")
    
    # Material parameters
    lines.append("# MATERIAL PARAMETERS")
    lines.append(f"Panel_Thickness = {request.materials.panel_thickness}")
    lines.append(f"Clearance = {request.clearance}")
    lines.append("")
    
    # Crate dimensions
    if "crate_dimensions" in results:
        dims = results["crate_dimensions"]
        lines.append("# CRATE DIMENSIONS")
        lines.append(f"Crate_Internal_Length = {dims.get('internal_length', 0)}")
        lines.append(f"Crate_Internal_Width = {dims.get('internal_width', 0)}")
        lines.append(f"Crate_Internal_Height = {dims.get('internal_height', 0)}")
        lines.append(f"Crate_External_Length = {dims.get('external_length', 0)}")
        lines.append(f"Crate_External_Width = {dims.get('external_width', 0)}")
        lines.append(f"Crate_External_Height = {dims.get('external_height', 0)}")
        lines.append("")
    
    # Panel dimensions
    if "panels" in results:
        lines.append("# PANEL DIMENSIONS")
        for panel_name, panel_data in results["panels"].items():
            if "error" not in panel_data:
                lines.append(f"# {panel_name.upper()} PANEL")
                if "width" in panel_data:
                    lines.append(f"{panel_name}_Width = {panel_data['width']}")
                if "height" in panel_data:
                    lines.append(f"{panel_name}_Height = {panel_data['height']}")
                if "length" in panel_data:
                    lines.append(f"{panel_name}_Length = {panel_data['length']}")
                lines.append("")
    
    # Standard lumber dimensions
    lines.append("# STANDARD LUMBER DIMENSIONS")
    lines.append("Cleat_Thickness = 1.5")
    lines.append("Cleat_Width = 3.5")
    lines.append("")
    
    # Assembly suppression flags
    lines.append("# ASSEMBLY SUPPRESSION FLAGS")
    lines.append("Suppress_Front_Panel = 0")
    lines.append("Suppress_Back_Panel = 0")
    lines.append("Suppress_Left_Panel = 0")
    lines.append("Suppress_Right_Panel = 0")
    lines.append(f"Suppress_Top_Panel = {0 if request.include_top else 1}")
    lines.append("")
    
    # Footer
    lines.append("# END OF EXPRESSION FILE")
    
    return "\n".join(lines)

@app.post("/api/export/bom")
async def export_bom(request: CrateRequest, format: str = "excel"):
    """Generate Bill of Materials"""
    try:
        # Calculate BOM
        engine = CalculationEngine()
        results = engine.calculate_crate(request)
        
        # Create BOM items
        bom_items = [
            BOMItem(
                category="Panels",
                description=f"3/4 inch Plywood Sheets (4x8)",
                quantity=results["materials_summary"]["plywood_sheets"],
                unit="sheets",
                unit_cost=45.00,
                total_cost=results["materials_summary"]["plywood_sheets"] * 45.00
            ),
            BOMItem(
                category="Lumber",
                description="2x4 Lumber",
                quantity=results["materials_summary"]["lumber_length_ft"],
                unit="linear ft",
                unit_cost=1.50,
                total_cost=results["materials_summary"]["lumber_length_ft"] * 1.50
            ),
            BOMItem(
                category="Hardware",
                description="Wood Screws #8 x 2.5",
                quantity=250,
                unit="pieces",
                unit_cost=0.12,
                total_cost=30.00
            )
        ]
        
        # Return JSON for now, implement Excel export later
        return {
            "project": f"Crate for {request.product.length}x{request.product.width}x{request.product.height}",
            "date": datetime.utcnow().isoformat(),
            "items": [item.dict() for item in bom_items],
            "total_cost": sum(item.total_cost for item in bom_items if item.total_cost)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/3d-geometry")
async def get_3d_geometry(request: CrateRequest):
    """Generate 3D geometry data for visualization"""
    try:
        # Calculate crate
        engine = CalculationEngine()
        results = engine.calculate_crate(request)
        
        # Generate 3D geometry
        geometry = {
            "panels": [],
            "cleats": [],
            "dimensions": results["crate_dimensions"]
        }
        
        # Front panel
        if "front" in results["panels"] and "error" not in results["panels"]["front"]:
            panel = results["panels"]["front"]
            geometry["panels"].append({
                "name": "front",
                "position": [0, 0, panel["height"]/2],
                "size": [panel["width"], request.materials.panel_thickness, panel["height"]],
                "color": "#8B4513"
            })
        
        # Back panel
        if "back" in results["panels"] and "error" not in results["panels"]["back"]:
            panel = results["panels"]["back"]
            geometry["panels"].append({
                "name": "back",
                "position": [0, results["crate_dimensions"]["internal_width"], panel["height"]/2],
                "size": [panel["width"], request.materials.panel_thickness, panel["height"]],
                "color": "#8B4513"
            })
        
        # Add more panels and cleats...
        
        return geometry
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/materials")
async def get_materials():
    """Get available materials and specifications"""
    return {
        "panel_materials": [
            {"value": "plywood", "label": "CDX Plywood", "grades": ["CDX", "ACX", "BCX"]},
            {"value": "osb", "label": "OSB", "grades": ["Standard", "Premium"]}
        ],
        "panel_thicknesses": [
            {"value": 0.5, "label": "1/2 inch"},
            {"value": 0.625, "label": "5/8 inch"},
            {"value": 0.75, "label": "3/4 inch"},
            {"value": 1.0, "label": "1 inch"}
        ],
        "lumber_sizes": [
            {"value": "1.5x3.5", "label": "2x4"},
            {"value": "1.5x5.5", "label": "2x6"},
            {"value": "1.5x7.25", "label": "2x8"},
            {"value": "1.5x9.25", "label": "2x10"}
        ]
    }

@app.get("/api/standards")
async def get_standards():
    """Get ASTM standards information"""
    return {
        "standards": [
            {
                "code": "ASTM D6251-17",
                "title": "Standard Specification for Wood-Cleated Panelboard Shipping Boxes",
                "description": "Covers requirements for wood-cleated panelboard shipping containers",
                "requirements": [
                    "Minimum safety factor of 1.5",
                    "Panel thickness based on contents weight",
                    "Cleat spacing requirements",
                    "Fastener specifications"
                ]
            },
            {
                "code": "ISPM 15",
                "title": "International Standards for Phytosanitary Measures",
                "description": "Requirements for wood packaging in international trade",
                "requirements": [
                    "Heat treatment or fumigation",
                    "Proper marking",
                    "Debarked wood"
                ]
            }
        ]
    }

# Run with: uvicorn api.main:app --reload --port 8000
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)